<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lua</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <main id="main-doc">
        <nav id="navbar">
            <header>Lua 5.1 Reference Manual</header>
            <div class="links">
                <a href="#introduction">Introduction</a>
                <a href="#language">The language</a>
                <a href="#interface">The application program interface (API)</a>
                <a href="#auxiliary-library">The auxiliary library</a>
                <a href="#standard-libraries">Standard Libraries</a>
                <a href="#standalone-language">Lua as a standalone language</a>
            </div>
        </nav>
        <div class="sections">
            <section class="main-section" id="introduction">
                <header>Introduction</header>
                <p>Lua is an extensible programming language designed for general procedural programming with data description utilities. It also offers good support for object-oriented programming, functional programming, and data-oriented programming. Lua is intended to be used as a powerful and lightweight scripting language for any program that needs it. Lua is implemented as a library written in clean C (that is, in the common subset of ANSI C and C++).</p>
                <p>Being an extension language, Lua has no notion of a main program: it only works embedded in a host client, called a container program or simply host. It can invoke functions to execute a piece of Lua code, it can write and read Lua variables, and it can register C functions to be called by Lua code. Through the use of C functions, Lua can be augmented to cover a wide range of different domains, thereby creating custom programming languages that share the same syntactic framework. The Lua distribution includes a sample host program called lua, which uses the Lua library to provide a complete, stand-alone Lua interpreter.</p>
                <p>Lua is free software, and is provided, as usual, without warranties, as stated in its license. The implementation described in this manual is available on the official Lua website, www.lua.org.</p>
                <p>Lua is free software, and is provided, as usual, without warranties, as stated in its license. The implementation described in this manual is available on the official Lua website, www.lua.org.</p>
            </section>
            <section class="main-section" id="language">
                <header>The language</header>
                <ol>
                    <li>
                        <h3>Lexical convections</h3>
                        <p>Names (also called identifiers) in Lua can be any string with only letters, digits, and underscore characters, not starting with a digit. This matches the definition of names in most languages. (The definition of letter depends on the current local implementation across the locale system: any character considered alphabetic on the local system can be used in an identifier.) Identifiers are used to name variables and table fields.</p>
                        <p>The following keywords are reserved and cannot be used as names: and break do else elseif false for function if in local nil not or repeat return then true until while</p>
                        <p>In Lua uppercase and lowercase letters are considered different: and is a reserved word, but And and AND are two different valid names. As a convention, names that begin with an underscore followed by uppercase letters (such as _VERSION) are reserved for use as internal Lua global variables.</p>
                        <p>The following strings denote other elements: + - * / % ^ # == ~= &lt;= &gt;= &lt; &gt; = ( ) { } [ ] ; : , . .. ...</p>
                        <p>Comments begin with a double hyphen (--) anywhere outside of a string. If the text immediately following -- is not a long square bracket, the comment is short and extends to the end of the line. In another case we have a long comment, which reaches up to the corresponding long closing bracket. Long comments are frequently used to temporarily disable chunks of code.</p>
                    </li>
                    <li>
                        <h3>Values and types</h3>
                        <p>Lua is a dynamically typed language . This means that variables do not have types; only values have type. There are no type definitions in the language. All values store their own type.</p>
                        <p>All values in Lua are first class values . This means that they can all be stored in variables, passed as arguments to functions, and also returned as results.</p>
                        <p>There are eight basic types in Lua: nil , boolean , number , string , function , userdata , thread , and table . Nil is the type of the nil value , whose main property is to be different from any other value; It usually represents the absence of useful value. Boolean is the type of the values false and true . Both nil and false make a condition false; any other value makes it true. Number represents real numbers (floating point and double precision). (It's easy to build Lua interpreters that use another internal representation for numbers, either single-precision floating point or long integers. See file luaconf.h.) String represents a string of characters. Lua works with 8 bits: strings can contain any 8-bit character, including the zero character (' \0').</p>
                        <p>Lua can call (and handle) functions written in Lua and functions written in C.</p>
                        <p>The userdata type is included to allow storing arbitrary data in C in Lua variables. This type corresponds to blocks of memory and has no predefined operations associated with Lua, except for assignment and identity testing. However, using § metatables , the programmer can define operations associated with values of type userdata. Values of this type cannot be created or modified in Lua, but only through the C API. This guarantees the integrity of the data owned by the host program.</p>
                        <p>The thread type represents execution processes and is used to implement coroutines. Lua processes should not be confused with those of the operating system. Lua supports coroutines on all systems, even those that do not support processes.</p>
                        <p>The table type implements associative arrays , that is, arrays that can be indexed not only with numbers, but also with any value (except nil ). Tables can be heterogeneous , as they can contain values of all types (except nil ). Tables are the only data structuring mechanism in Lua; They can be used to represent ordinary arrays , symbol tables, sets, records, graphs, trees, etc. To represent records Lua uses the field name as an index. The language supports this representation by making the notation b.name equivalent to b["name"]. There are several convenient ways to create tables in Lua.</p>
                        <p>Like indexes, the values of a table's fields can also be of any type (except nil ). In particular, because functions are first-class values, table fields can contain functions. Then tables can also contain methods.</p>
                        <p>The values of tables, functions, processes and (full) userdata are objects : variables do not actually contain those values, but only reference them . Assignment, argument passing, and return functions always handle references to those values; These operations do not imply any type of copy.</p>
                        <p>The library function typereturns a string that describes the type of a given value.</p>
                    </li>
                    <li>
                        <h3>Coercion</h3>
                        <p>Lua can automatically convert between string values and numeric values at runtime. Any arithmetic operation applied to a string attempts to convert it into a number, following the normal conversion rules. And vice versa, when a number is used where a string is expected the number is converted to a string , with a reasonable format. For complete control in converting numbers to strings the stringformat handling library function should be used (see ).string.format</p>
                    </li>
                    <li>
                        <h3>Variables</h3>
                        <p>Variables are places where values are stored. There are three types of variables in Lua: global, local, and table fields.</p>
                        <p>A single name can denote a local or a global variable (or a formal argument to a function, which is a particular form of a local variable):</p>
                        <code>var ::= name</code>
                        <p>Lua assumes that variables are global, unless they are explicitly declared local. Local variables have a lexically defined scope : they can be freely accessed from within functions defined in their same scope.</p>
                        <p>Before the first assignment the value of a variable is nil .</p>
                        <p>Brackets are used to index a table:</p>
                        <code>var ::= prefixexp ' [ ' exp ' ] '</code>
                        <p>The first expression ( prefixexp ) must result in a table value; The second expression ( exp ) identifies a specific entry in this table. The expression denoting the table that is indexed has a restricted syntax.</p>
                        <p>The syntax var.name is another way of expressing var["name"]and is used to denote table fields:</p>
                        <code>var ::= prefixexp ' . ' name</code>
                        <p>The way global variables and table fields are accessed can be changed using metatables. An access to the indexed variable t[i]is equivalent to a call to gettable_event(t,i).</p>
                        <p>All global variables are stored as fields of ordinary tables in Lua, called environment tables or simply environments. Each function has its own reference to an environment, so all global variables in this function refer to that environment table. When a function is created, it inherits the environment of the function that created it. To obtain the environment table of a function in Lua code, getfenv. To replace it, call setfenv.</p>
                        <p>An access to the global variable xis equivalent to _env.x, which in turn is equivalent to</p>
                        <code>gettable_event(_env, "x")</code>
                        <p>where _envis the environment of the function that is currently being executed.</p>
                    </li>
                    <li>
                        <h3>Sentences</h3>
                        <p>Lua supports a nearly conventional set of statements, similar to those of Pascal or C. This set includes assignment, control flow structures, function calls, table constructors, and variable declarations.</p>
                        <ul>
                            <li>
                                <h4>Chunks</h4>
                                <p>The unit of execution in Lua is called a chunk , which is simply a set of statements that are executed sequentially. Each statement can optionally have a semicolon at the end:</p>
                                <code>chunk ::= { statement [' ; ']}</code>
                                <p>There are no empty statements in Lua and therefore ' ;;' is not legal.</p>
                                <p>Lua handles each chunk as the body of an anonymous function with a variable number of arguments. Chunks can define local variables , receive arguments and return values.</p>
                                <p>A chunk can be stored in a file or in a string within a host program. When a chunk is executed, it is first precompiled, creating instructions for a virtual machine, and then the compiled code is executed by a virtual machine interpreter.</p>
                                <p>A chunk can be stored in a file or in a string within a host program. When a chunk is executed, it is first precompiled, creating instructions for a virtual machine, and then the compiled code is executed by a virtual machine interpreter.</p>
                            </li>
                            <li>
                                <h4>Blocks</h4>
                                <p>A block is a list of statements; Syntactically, a block is the same as a chunk :</p>
                                <code>block ::= chunk</code>
                                <p>A block can be explicitly delimited to produce a simple statement:</p>
                                <code>statement ::= do end block</code>
                                <p>Explicit blocks are useful for controlling the scope of variable declarations. They are also sometimes used to add return or break statements in the middle of another block.</p>
                            </li>
                            <li>
                                <h4>The assignment</h4>
                                <p>Lua allows multiple assignments. Therefore the syntax of an assignment defines a list of variables on the left and a list of expressions on the right. The elements of both lists are separated by commas:</p>
                                <code>statement ::= varlist ' = ' explist</code><br>
                                <code>varlist ::= var {' , ' var}</code><br>
                                <code>explist ::= exp {' , ' exp}</code>
                                <p>Before an assignment the list of expressions is adjusted to the length of the list of variables. If there are more values than necessary, the excess is discarded. If there are fewer values than necessary, the list is extended with as many nil values as needed. If the expression list ends with a function call then all values returned in the call can enter the value list before wrapping.</p>
                                <p>The assignment statement first evaluates all its expressions and only then the assignment is made. So the code</p>
                                <code>i = 3</code><br>
                                <code>i, b[i] = i+1, 20</code>
                                <p>assigns 20 to b[3], without affecting a b[4]because iin b[i]is evaluated (a 3) before it is assigned the value 4. Similarly, the line</p>
                                <code>x,y = y,x</code>
                                <p>swap the values of xe y.</p>
                                <p>The assignment mechanism to global variables and table fields can be modified using metatables. An assignment to an indexed variable t[i] = valis equivalent to settable_event(t,i,val).</p>
                                <p>An assignment to the global variable x = valis equivalent to assignment _env.x = val, which in turn is equivalent to</p>
                                <code>settable_event(_env, "x", val)</code>
                                <p>where _envis the environment of the function that is currently running. (The variable _envis not defined in Lua. It is used here for illustrative purposes only.)</p>
                            </li>
                            <li>
                                <h4>Control structures</h4>
                                <p>The if , while , and repeat control structures have the usual meaning and familiar syntax:</p>
                                <code>   statement ::= while exp do block end </code><br>
                                <code>   statement ::= repeat block until exp</code>
                                <code>   statement ::= if exp then block { elseif exp then block} [ else block] end</code>
                                <p>Lua also has a for statement , in two formats.</p>
                                <p>The condition of an expression of a control structure can return any value. Both false and nil are considered false. All values other than nil and false are considered true (in particular, the number 0 and the empty string are also true).</p>
                                <p>In the repeat - until loop the internal block does not end with the until keyword but after the condition. This way the condition can refer to local variables declared within the loop block.</p>
                                <p>The return command is used to return values from a function or a chunk (which is just a function). Functions and chunks can return more than one value, so the syntax for return is</p>
                                <code>   statement ::= return [explist]</code>
                                <p>The break command is used to terminate the execution of the while , repeat and for loops , jumping to the statement that follows after the loop:</p>
                                <code>statement ::= break</code>
                                <p>A break ends the innermost loop that is active.</p>
                                <p>The return and break commands can appear only as the last statement within a block. If you really need a return or a break in the middle of a block you should use an inner block explicitly, as in ' do return end' and ' do break end', because then return and break are the last statements in their own block.</p>
                            </li>
                            <li>
                                <h4>The for statement</h4>
                                <p>The for statement has two forms: a numerical one and a generic one.</p>
                                <p>The numerical form of the for loop repeats a block while a control variable follows an arithmetic progression. It has the following syntax:</p>
                                <code>statement ::= for name ' = ' exp1 ' , ' exp2 [' , ' exp3] do block end</code>
                                <p>The block repeats for name values starting at exp1 until it passes exp2 using exp3 as a step . More precisely a for statement like</p>
                                <code>for v = e1 , e2 , e3 do end</code>
                                <p> block</p>
                                <p>equivalent to the code:</p>
                                <code>do</code>   <br>
                                <code> local var , limit , step = tonumber( e1 ), tonumber( e2 ), tonumber( e3 )</code> <br>
                                <code> if not ( var and limit and step ) then error() end</code> <br>
                                <code> while ( step &gt; 0 and var &lt;= limit ) or ( step &lt;= 0 and var >= limit ) do</code> <br>
                                <code> local v = var</code> <br>
                                <code> block </code> <br>
                                <code> var = var + step</code> <br>
                                <code> end</code> <br>
                                <code>end</code> <br>
                                <p>Note the following:</p>
                                <p>All control expressions are evaluated only once, before the loop begins. They must all result in numbers.</p>
                                <p>var , limit and step are invisible variables. Names appear here for illustrative purposes only.</p>
                                <p>If the third expression (the step) is absent, step 1 is used.</p>
                                <p>You can use break to exit the for loop .</p>
                                <p>The control variable vis local within the loop; its value cannot be used after the for loop ends or after an exit from it with break . If the value of the variable is needed varthen it must be assigned to another variable before the break or exit of the loop.</p>
                                <p>The generic for statement works with functions, called iterators . In each iteration, the iterator function is invoked to produce a new value, stopping the iteration when the new value is nil . The generic for loop has the following syntax:</p>
                                <code>statement ::= for list_of_names in explist do block end </code> <br>
                                <code>list_of_names ::= name {' , ' name}</code>
                                <p>A for statement like</p>
                                <code>for var_1 , ..., var_n in explist do end</code>
                                <p>block</p>
                                <p>equivalent to the code:</p>
                                <code>do</code> <br>
                                <code>local f , s , var = explist</code> <br>
                                <code>while true do</code> <br>
                                <code>local var_1 , ..., var_n = f ( s , var )</code> <br>
                                <code>var = var_1</code>  <br>
                                <code>if var == nil then break end</code>
                                <code>block</code> <br>
                                <code>end</code> <br>
                                <code>end</code>
                                <p>Note the following:</p>
                                <p>explist is evaluated only once. Its results are an iterator function , a state , and an initial value for the first iterator variable .</p>
                                <p>f , s and var are invisible variables. The names that appear here are only illustrative.                             </p>
                                <p>A break command can be used to exit the for loop .</p>
                                <p>The loop control variables var_i are local to the loop; their values cannot be used after the for loop ends . If their values are needed, they must be assigned to other variables before the loop is exited (usually or with a break ).</p>
                            </li>
                            <li>
                                <h4>Function call statements</h4>
                                <p>To avoid possible side effects, function calls can be made as statements:</p>
                                <code>   statement ::= call_to_func</code>
                                <p>In that case all returned values are discarded.</p>
                            </li>
                            <li>
                                <h4>Local declarations</h4>
                                <p>Local variables can be declared anywhere within a block. Those statements may include an initial allocation:</p>
                                <code>statement ::= local name_list [' = ' explist]</code>
                                <p>If present, an initial assignment has the same semantics as a multiple assignment. Otherwise all variables are initialized with nil .</p>
                                <p>A chunk is also a block, so local variables can be declared in a chunk outside of any explicit block. The scope of those variables extends to the end of the chunk .</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>Expressions</h3>
                        <p>The basic expressions in Lua are as follows:</p>
                        <code>exp ::= prefixexp</code> <br>
                        <code> exp ::= nil   |  false   |  true</code> <br>
                        <code>exp ::= Number</code> <br>
                        <code>exp ::= String</code> <br>
                        <code>exp ::= func</code> <br>
                        <code>exp ::= table_constructor</code> <br>
                        <code>exp ::= ' ... '</code> <br>
                        <code>exp ::= exp binary_operator exp</code> <br>
                        <code>exp ::= unary_operator exp</code> <br>
                        <code>prefixexp ::= var | call_to_func | ' ( 'exp' ) '</code>
                        <ul>
                            <li>
                                <h4>Arithmetic operators</h4>
                                <p>Lua has the common arithmetic operators: the binary ones +(addition), -(subtraction), *(multiplication), /(division), %(module) and ^(exponentiation); and the unary -(negation). If the operands are numbers or strings that are converted to numbers (see §2.2.1 ), then all operations have their ordinary meaning. Exponentiation works with any exponent. For example, x^(-0.5)calculate the inverse of the square root of x. The module is defined as</p>
                                <code>a % b == a - math.floor(a/b)*b</code>
                                <p>That is, it is the remainder of the division that rounds the quotient towards minus infinity.</p>
                            </li>
                            <li>
                                <h4>Relational operators</h4>
                                <p>Relational operators in Lua are</p>
                                <code>== ~= &lt; > &lt;= >=</code>
                                <p>They always return a false or true result .</p>
                                <p>Equality ( ==) first compares the type of the operands. If they are different then the result is false . In another case, the values of the operands are compared. Numbers and strings are compared in the usual way. Objects (tables, userdata , processes and functions) are compared by reference : two objects are considered equal only if they are the same object. Every time a new object is created (a table, userdata , process or function) this new object is different from all other pre-existing objects.</p>
                                <p>You can change the way Lua compares tables and userdata using the "eq" metamethod.</p>
                                <p>The conversion rules in §2.2.1 do not apply in equality comparisons. Thus "0"==0false , and t[0]and t["0"]denote different entries in a table.</p>
                                <p>The operator ~=is exactly the negation of equality ( ==).</p>
                                <p>The order of the operators works as follows. If both arguments are numbers then they are compared as such. Otherwise, if both arguments are strings , their values are compared according to the local system. Otherwise, Lua tries to use the "lt" or "le" metamethods.</p>
                            </li>
                            <li>
                                <h4>Logical operators</h4>
                                <p>The logical operators in Lua are and , or and not . Like control structures (see §2.4.4 ) all logical operators consider false and nil to be false and everything else to be true.</p>
                                <p>The negation not operator always returns false or true . The conjunction operator and returns its first operand if its value is false or nil ; otherwise and returns its second operand. The disjunction or operator returns its first operand if its value is different from nil and false ; otherwise or returns its second argument. Both and and or use short-circuit evaluation ; that is, its second operand is evaluated only if necessary. Here are several examples:</p>
                                <code>10 or 20 --&gt; 10</code> <br>
                                <code>10 or error() --&gt; 10</code> <br>
                                <code>nil or "a" --&gt; "a"</code> <br>
                                <code>nil and 10 --&gt; nil</code> <br>
                                <code>false and error() --&gt; false</code> <br>
                                <code>false and nil --&gt; false</code> <br>
                                <code>false or nil --&gt; nil</code> <br>
                                <code>10 and 20 --&gt; 20</code>
                            </li>
                            <li>
                                <h4>Concatenation</h4>
                                <p>The string concatenation operator in Lua is denoted by a colon (' ..').</p>
                            </li>
                            <li>
                                <h4>The length operator</h4>
                                <p>The length operator is denoted by #. The length of a string is its number of bytes (normal meaning of the length of a string when each character occupies one byte).</p>
                                <p>The length of a table tis defined as an integer index nsuch that t[n]it is not nil and t[n+1]is nil ; also if t[1]it is nil then nit can be zero. For a regular array , with non- nil values ​​from 1 to a ngiven, the length is exactly n, the index is its last value. If the array has "holes" (that is, nil values ​​between other non-nil values), then #tit can be any of the indexes that precede a nil value (that is, Lua can consider that nil value as the end of the array ).</p>
                            </li>
                            <li>
                                <h4>Operator precedence</h4>
                                <p>The precedence of operators in Lua follows the following table from lowest to highest priority:</p>
                                <code>or</code> <br>
                                <code>and</code> <br>
                                <code>&lt; &gt; &lt;= &gt;= ~= ==</code> <br>
                                <code>..</code> <br>
                                <code>+ -</code> <br>
                                <code>*/%</code> <br>
                                <code>not # - (unary)</code> <br>
                                <code>^</code>
                                <p>As usual, parentheses can be used to change precedence in an expression. The concatenation (' ..') and exponentiation (' ^') operators are right-associative. All other operators are left associative.</p>
                            </li>
                            <li>
                                <h4>Table constructors</h4>
                                <p>Table constructors are expressions that create tables. Every time a constructor is evaluated a new table is created. Constructors can be used to create empty tables or to create tables and initialize some of their fields. The general syntax for those constructors is</p>
                                <code>table_constructor ::= ' { ' [field_list] ' } '</code> <br>
                                <code>field_list ::= field {field_separator field} [field_separator]</code> <br>
                                <code>field ::= ' [ ' exp ' ] ' ' = ' exp | name ' = ' exp | exp</code> <br>
                                <code>field_separator ::= ' , ' | ' ; '</code>
                                <p>Each field in the form [exp1] = exp2adds an entry to the new table with the key exp1and with the value exp2. A field of the form nombre = expis equivalent to ["nombre"] = exp. Finally, fields of the form expare equivalent to [i] = exp, where ithey are consecutive integers, starting with 1. Fields in the other format do not affect this counter. For example,</p>
                                <code>a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; Four. Five }</code>
                                <p>equals</p>
                                <code>do</code> <br>
                                <code>local t = {}</code> <br>
                                <code>t[f(1)] = g</code> <br>
                                <code>t[1] = "x" -- 1st exp</code> <br>
                                <code>t[2] = "and" -- 2nd exp</code> <br>
                                <code>tx = 1 -- t["x"] = 1</code> <br>
                                <code>t[3] = f(x) -- 3rd exp</code> <br>
                                <code>t[30] = 23</code> <br>
                                <code>t[4] = 45 -- 4th exp</code> <br>
                                <code>a = t</code> <br>
                                <code>end</code>
                                <p>If the last field in the list has the form expand the expression is a function call or an expression vararg , then all values returned by this expression enter the list consecutively .To avoid this you should enclose the function call (or the vararg expression ) in parentheses.</p>
                                <p>The list of fields can have an optional separator at the end, a convenience for automatically generated source code.</p>
                            </li>
                            <li>
                                <h4>Function calls</h4>
                                <p>A call to a function has the following syntax in Lua:</p>
                                <code>func_call ::= prefixexp arguments</code>
                                <p>In a function call, prefixexp and the arguments are evaluated first . If the value of prefixexp is of type function , then this function is called with the given arguments. Otherwise, the "call" metamethod is invoked, passing as the first argument the value of prefixexp followed by the original arguments of the call.</p>
                                <p>The shape</p>
                                <code>func_call ::= prefixexp ' : ' name arguments</code>
                                <p>can be used to invoke "methods". A call v:nombre(...)is another way of expressing v.nombre(v,...), except that vit is evaluated only once.</p>
                                <p>The arguments have the following syntax:</p>
                                <code>arguments ::= ' ( ' [explist] ' ) '</code> <br>
                                <code>arguments ::= table_constructor</code> <br>
                                <code>arguments ::= String</code>
                                <p>All arguments to the expression are evaluated before the call. A form call f{...}is another way of expressing f({...}); that is, the argument list is a new simple table. A call of the form f'...'(o f"..."or f[[...]]) is another way of expressing f('...'); that is, the argument list is a simple string literal.</p>
                                <p>As an exception to Lua's free-form syntax, you cannot put a line break before ' &#40;' in a function call. This restriction avoids some ambiguities in the language. If you write</p>
                                <code>a = f</code> <br>
                                <code>(g).x(a)</code>
                                <p>Lua could understand it as a simple statement, a = f(g).x(a). So, if you want two statements, you must add a semicolon between them. If you really want to call f, you must remove the line break before (g).</p>
                                <p>A call of the form return call_a_func is called a tail call . Lua implements correct tail calls (or correct tail recursion ): in a tail call the invoked function reuses the entry on the stack of the function that is calling it. Therefore there is no limit on the number of nested tail calls that a program can execute. However a tail call clears any debugging information regarding the calling function. Note that a tail call only occurs with a particular syntax where return has a simple function call as an argument; This syntax causes the calling function to return exactly the return of the called function. According to this, none of the following examples are tail calls:</p>
                                <code>return (f(x)) -- results set to 1</code> <br>
                                <code>return 2 * f(x)</code> <br>
                                <code>return x, f(x) -- additional results</code> <br>
                                <code>f(x); return -- discarded results</code> <br>
                                <code>return x or f(x) -- results set to 1</code>
                            </li>
                            <li>
                                <h4>Definition of functions</h4>
                                <p>The syntax for defining functions is</p>
                                <code>func ::= function func_body</code> <br>
                                <code>func_body ::= ' ( ' [arg_list] ' ) ' end block</code>
                                <p>The following way simplifies the definition of functions:</p>
                                <code>statement ::= function func_name</code> <br>
                                <code>statement ::= local  function name func_body</code> <br>
                                <code>func_name ::= name {' . ' name} [' : ' name]</code>
                                <p>Sentence</p>
                                <code>function f () function_body end</code>
                                <p>translates into</p>
                                <code>f = function () function_body end</code>
                                <p>Sentence</p>
                                <code>function tabcf() function_body end</code>
                                <p>translates into</p>
                                <code>tabcf = function () function_body end</code>
                                <p>Sentence</p>
                                <code>local function f () function_body end</code>
                                <p>translates into</p>
                                <code>local f; f = function () function_body end</code>
                                <p>not in:</p>
                                <code>local f = function () function_body end</code>
                                <p>(This only makes a difference when the function body contains references to f.)</p>
                                <p>A function definition is an executable expression, whose value has type function . When Lua precompiles a chunk all its function bodies are also precompiled. So when Lua executes the function definition, it is instantiated (or closed ). This function instance (or closure ) is the final value of the expression. Different instances of the same function can refer to different external local variables and can have different environment tables.</p>
                                <p>The formal arguments of a function act as local variables that are initialized with the current values of the arguments:</p>
                                <code>argument_list ::= name_list [' , ' ' ... '] | ' ... '</code>
                                <p>When a function is invoked, the current argument list is adjusted to the length of the formal argument list, unless the function is of type vararg , which is indicated by three dots (' ...') at the end of the list of formal arguments. A vararg function does not adjust its argument list; instead it collects all the extra current arguments and passes them to the function via a vararg expression , also indicated by three dots. The value of this expression is a list of all the current extra arguments, similar to a function with multiple results. If the vararg expression is used inside another expression or in the middle of a list of expressions, then its return wraps to a single element. If the expression is used as the last element of a list of expressions then no adjustment is made (unless the call is made between parentheses).</p>
                                <p>As an example, let's consider the following definitions:</p>
                                <code>function f(a, b) end</code> <br>
                                <code>function g(a, b, ...) end</code> <br>
                                <code>function r() return 1,2,3 end</code>
                                <p>Then we have the following correspondence from the current arguments to the formal ones and to the vararg expression :</p>
                                <p>CALL ARGUMENTS</p>
                                <code>f(3) a=3, b=nil</code> <br>
                                <code>f(3, 4) a=3, b=4</code> <br>
                                <code>f(3, 4, 5) a=3, b=4</code> <br>
                                <code>f(r(), 10) a=1, b=10</code> <br>
                                <code>f(r()) a=1, b=2</code> <br>
                                <br>
                                <code>g(3) a=3, b=nil, ... --&gt; (nothing)</code> <br>
                                <code>g(3, 4) a=3, b=4, ... --&gt; (nothing)</code> <br>
                                <code>g(3, 4, 5, 8) a=3, b=4, ... --&gt; 5 8</code> <br>
                                <code>g(5, r()) a=5, b=1, ... --&gt; 2 3</code>
                                <p>The results are returned using the return statement. If the program flow reaches the end of a function without encountering a return statement then the function returns without results.</p>
                                <p>The colon (' :') syntax is used to define methods , that is, functions that have an extra argument called self. Then the sentence</p>
                                <code>function tabc:f ( params ) function_body end</code>
                                <p>is another way of expressing</p>
                                <code>tabcf = function (self, params ) function_body end</code>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>Visibility rules</h3>
                        <p>Lua is a language with lexical scope. The scope of variables begins in the first statement after its declaration and ends at the end of the innermost block that includes the declaration. Let's consider the following example:</p>
                        <code>x = 10 -- global variable</code> <br>
                        <code>do -- new block</code> <br>
                        <code>local x = x -- new 'x', with value 10</code> <br>
                        <code>print(x) --&gt; 10</code> <br>
                        <code>x = x+1</code> <br>
                        <code>do -- another block</code> <br>
                        <code>local x = x+1 -- another 'x'</code> <br>
                        <code>print(x) --&gt; 12</code> <br>
                        <code>end</code> <br>
                        <code>print(x) --&gt; 11</code> <br>
                        <code>end</code> <br>
                        <code>print(x) --&gt; 10 (the value of the global variable)</code> <br>
                        <p>Keep in mind that in a declaration like local x = x, the new xone being declared does not have scope yet, and the second one xrefers to the external variable.</p>
                        <p>Due to lexical scope rules, local variables can be accessed by functions defined inside their own scope. A local variable used in an internal function is called an upvalue or external local variable inside the function.</p>
                        <p>Note that each execution of a local statement defines new local variables. Consider the following example:</p>
                        <code>a = {}</code> <br>
                        <code>local x = 20</code> <br>
                        <code>for i=1.10 c</code> <br>
                        <code>local y = 0</code> <br>
                        <code>a[i] = function () y=y+1; return x+y end</code><br>
                        <code>end</code>
                        <p>The loop creates ten closures (that is, ten instances of an anonymous function). Each of these instances uses a ydifferent variable, while all of them share the same one x.</p>
                    </li>
                    <li>
                        <h3>Error handling</h3>
                        <p>Because Lua is an embedded extension language, all Lua actions begin with C code in the host program by calling a function from the Lua library (see lua_pcall). Whenever an error occurs during compilation or execution of Lua, control returns to C, which can take appropriate action (such as printing an error message).</p>
                        <p>An error can be raised (or triggered) explicitly in Lua by invoking the error. If you need to capture errors in Lua you can use the function pcall.</p>
                    </li>
                    <li>
                        <h3>Metatables</h3>
                        <p>Every value in Lua can have a metatable . This is an ordinary Lua table that defines the behavior of the original value for certain special operations. Various aspects of the behavior of operations performed on a value can be changed by setting specific fields in its metatable. For example, when a non-numeric value is an operand of an addition Lua looks for a function in the field "__add"of its metatable. If one is found, then that function is called to perform the addition.</p>
                        <p>We call the fields of a metatable events and we call the values metamethods . In the previous example the event is "add"while the metamethod is the function that performs the addition.</p>
                        <p>The metatable of any value can be requested through the function getmetatable.</p>
                        <p>You can replace the metatable of a table through the function setmetatable. You cannot change the metatable of other data types from Lua (except using the debug library); You must use the C API for this.</p>
                        <p>Full tables and userdata have individual metatables (although multiple tables and userdata can share their metatables); the values of the other types share a single metatable per type. Therefore, there is a single metatable for all numbers, another for all strings , etc.</p>
                        <p>A metatable can control how an object behaves in arithmetic operations, order comparisons, concatenation, length operations, and indexing. A metatable can also define a function that will be called when memory occupied by userdata is released . A specific key called an event is associated with each of these Lua operations . When Lua performs one of these operations on a value, it checks if it has a metatable with the corresponding event. If so, the value associated with that key (the metamethod ) controls how Lua performs the operation.</p>
                        <p>Metatables control the operations listed below. Each operation is identified by its corresponding name. The key associated with each operation is a string with its name prefixed with two underscores, ' __'; for example, the key for the "add" operation is the string "__add" . The semantics of those operations are best exposed through a Lua function that describes how the interpreter executes the operation.</p>
                        <p>The Lua code shown here is illustrative only; the actual behavior is coded internally in the interpreter and is much more efficient than this simulation. All functions used in these descriptions ( rawget, tonumber, etc.) are described in §5.1 . In particular, to retrieve the metamethod of a given object, we use the expression</p>
                        <code>metatable(object)[event]</code>
                        <p>This can also be expressed by</p>
                        <code>rawget(getmetatable(object) or {}, event)</code>
                        <p>Therefore, accessing a metamethod does not invoke other metamethods, and accessing objects without metatables does not fail (it simply returns nil ).</p>
                        <ul>
                            <li>
                                <h4>add</h4>
                                <p>The operation +.</p>
                                <p>The function getbinhandlerbelow defines how Lua chooses a binary operation handler. First Lua tests the first operand. If your type does not define a handler for the operation then Lua tries it with the second operand.</p>
                                <code>function getbinhandler(op1, op2, event)</code><br>
                                <code>return metatable(op1)[event] or metatable(op2)[event]</code><br>
                                <code>end</code><br>
                                <p>Using this function the behavior of the code op1 + op2is</p>
                                <code>function add_event (op1, op2)</code><br>
                                <code>local o1, o2 = tonumber(op1), tonumber(op2)</code><br>
                                <code>if o1 and o2 then -- are both operands numeric?</code><br>
                                <code>return o1 + o2 -- '+' here is the 'add' primitive</code><br>
                                <code>else -- at least one of the operands is non-numeric</code><br>
                                <code>local h = getbinhandler(op1, op2, "__add")</code><br>
                                <code>if h then</code><br>
                                <code>-- invokes the handler of both operands</code><br>
                                <code>return (h(op1, op2))</code><br>
                                <code>else -- no handler available: default behavior</code><br>
                                <code>mistake(···)</code><br>
                                <code>end</code><br>
                                <code>end</code><br>
                                <code>end</code><br>
                            </li>
                            <li>
                                <h4>sub</h4>
                                <p>The operation -.</p>
                                <p>The behavior is similar to the "add" operation.</p>
                            </li>
                            <li>
                                <h4>mul</h4>
                                <p>The behavior is similar to the "add" operation.</p>
                            </li>
                            <li>
                                <h4>div</h4>
                                <p>The operation /.</p>
                                <p>The behavior is similar to the "add" operation.</p>
                            </li>
                            <li>
                                <h4>mod</h4>
                                <p>The operation %. </p>
                                <p>The behavior is similar to the "add" operation, using it o1 - floor(o1/o2)*o2as a primitive operation.</p>
                            </li>
                            <li>
                                <h4>pow</h4>
                                <p>The operation ^(exponentiation).</p>
                                <p>The behavior is similar to the "add" operation, with the function pow(from the C math library) as the primitive operation.</p>
                            </li>
                            <li>
                                <h4>unm</h4>
                                <p>The unary operation .</p>
                                <code>function unm_event (op)</code><br>
                                <code>local o = tonumber(op)</code><br>
                                <code>if or then -- is the operand numeric?</code><br>
                                <code>return -o -- '-' here is the primitive function 'unm'</code><br>
                                <code>else -- the operand is not numeric.</code><br>
                                <code>-- try to get a handle for the operand</code><br>
                                <code>local h = metatable(op).__unm</code><br>
                                <code>if h then</code><br>
                                <code>-- invoke handler with operand</code><br>
                                <code>return (h(op))</code><br>
                                <code>else -- no handler available: default behavior</code><br>
                                <code>mistake(···)</code><br>
                                <code>end</code><br>
                                <code>end</code><br>
                                <code>end</code>
                            </li>
                            <li>
                                <h4>concat</h4>
                                <p>The operation ..(concatenation).</p>
                                <code>function concat_event (op1, op2)</code><br>
                                <code>if (type(op1) == "string" or type(op1) == "number") and</code><br>
                                <code>(type(op2) == "string" or type(op2) == "number") then</code><br>
                                <code>return op1 .. op2 -- primitive string concatenation</code><br>
                                <code>else</code><br>
                                <code>local h = getbinhandler(op1, op2, "__concat")</code><br>
                                <code>if h then</code><br>
                                <code>return (h(op1, op2))</code><br>
                                <code>else</code><br>
                                <code>mistake(···)</code><br>
                                <code>end</code><br>
                                <code>end</code><br>
                                <code>end</code>
                            </li>
                            <li>
                                <h4>len</h4>
                                <p>The operation #.</p>
                                <code>function len_event (op)</code><br>
                                <code>if type(op) == "string" then</code><br>
                                <code>return strlen(op) -- primitive length of string</code><br>
                                <code>elseif type(op) == "table" then</code><br>
                                <code>return #op -- table primitive length</code><br>
                                <code>else</code><br>
                                <code>local h = metatable(op).__len</code><br>
                                <code>if h then</code><br>
                                <code>-- invoke handler with operand</code><br>
                                <code>return (h(op))</code><br>
                                <code>else -- no handler available: default behavior</code><br>
                                <code>mistake(···)</code><br>
                                <code>end</code><br>
                                <code>end</code><br>
                                <code>end</code>
                            </li>
                            <li>
                                <h4>eq</h4>
                                <p>The operation ==.</p>
                                <p>The function getcomphandlerdefines how Lua chooses a metamethod for the comparison operator. A metamethod is selected when both objects being compared have the same type and the same metamethod for the given operation.</p>
                                <code>function getcomphandler(op1, op2, event)</code><br>
                                <code>if type(op1) ~= type(op2) then return nil end</code><br>
                                <code>local mm1 = metatable(op1)[event]</code><br>
                                <code>local mm2 = metatable(op2)[event]</code><br>
                                <code>if mm1 == mm2 then return mm1 else return nil end</code><br>
                                <code>end</code>
                                <p>The "eq" event is defined like this:</p>
                                <code>function eq_event (op1, op2)</code><br>
                                <code>if type(op1) ~= type(op2) then -- different types?</code><br>
                                <code>return false -- different objects</code><br>
                                <code>end</code><br>
                                <code>if op1 == op2 then -- equal primitives?</code><br>
                                <code>return true -- objects are equal</code><br>
                                <code>end</code><br>
                                <code>-- test a metamethod</code><br>
                                <code>local h = getcomphandler(op1, op2, "__eq")</code><br>
                                <code>if h then</code><br>
                                <code>return (h(op1, op2))</code><br>
                                <code>else</code><br>
                                <code>return false</code><br>
                                <code>end</code><br>
                                <code>end</code>
                                <p>a ~= bequals not (a == b).</p>
                            </li>
                            <li>
                                <h4>lt</h4>
                                <p>The operation &lt;.</p>
                                <code>function lt_event(op1, op2)</code><br>
                                <code>if type(op1) == "number" and type(op2) == "number" then</code><br>
                                <code>return op1 &lt; op2 -- numerical comparison</code><br>
                                <code>elseif type(op1) == "string" and type(op2) == "string" then</code><br>
                                <code>return op1 &lt; op2 -- lexicographic comparison</code><br>
                                <code>else</code><br>
                                <code>local h = getcomphandler(op1, op2, "__lt")</code><br>
                                <code>if h then</code><br>
                                <code>return (h(op1, op2))</code><br>
                                <code>else</code><br>
                                <code>mistake(···);</code><br>
                                <code>end</code><br>
                                <code>end</code><br>
                                <code>end</code>
                                <p>a > b equals b &lt; a.</p>
                            </li>
                            <li>
                                <h4>le</h4>
                                <p>The operation &lt;=.</p>
                                    <code>function le_event (op1, op2)</code><br>
                                    <code>if type(op1) == "number" and type(op2) == "number" then</code><br>
                                    <code>return op1 &lt;= op2 -- numerical comparison</code><br>
                                    <code>elseif type(op1) == "string" and type(op2) == "string" then</code><br>
                                    <code>return op1 &lt;= op2 -- lexicographic comparison</code><br>
                                    <code>else</code><br>
                                    <code>local h = getcomphandler(op1, op2, "__le")</code><br>
                                    <code>if h then</code><br>
                                    <code>return h(op1, op2)</code><br>
                                    <code>else</code><br>
                                    <code>h = getcomphandler(op1, op2, "__lt")</code><br>
                                    <code>if h then</code><br>
                                    <code>return not h(op2, op1)</code><br>
                                    <code>else</code><br>
                                    <code>mistake(···);</code><br>
                                    <code>end</code><br>
                                    <code>end</code><br>
                                    <code>end</code><br>
                                    <code>end</code>
                                <P>a >= b equals b &lt;= a. Keep in mind that in the absence of a "le" metamethod Lua tries to use the "lt" one, assuming it is a &lt;= bequivalent to not (b &lt; a).</P>
                            </li>
                            <li>
                                <h4>index</h4>
                                <p>Indexed access tabla[clave].</p>
                                <code>function gettable_event(table, key)</code><br>
                                <code>local h</code><br>
                                <code>if type(table) == "table" then</code><br>
                                <code>local v = rawget(table, key)</code><br>
                                <code>if v ~= nil then return v end</code>
                                <code>h = metatable(table).__index</code><br>
                                <code>if h == nil then return nil end</code><br>
                                <code>else</code><br>
                                <code>h = metatable(table).__index</code><br>
                                <code>if h == nil then</code><br>
                                <code>mistake(···);</code><br>
                                <code>end</code><br>
                                <code>end</code><br>
                                <code>if type(h) == "function" then</code><br>
                                <code>return (h(table, key)) -- invoke handler</code><br>
                                <code>else return h[key] -- or repeat the operation with it</code><br>
                                <code>end</code><br>
                                <code>end</code>
                            </li>
                            <li>
                                <h4>newindex</h4>
                                <p>The indexed assignment tabla[clave] = valor.</p>
                                <code>function settable_event(table, key, value)</code><br>
                                <code>local h</code><br>
                                <code>if type(table) == "table" then</code><br>
                                <code>local v = rawget(table, key)</code><br>
                                <code>if v ~= nil then rawset(table, key, value); return end</code><br>
                                <code>h = metatable(table).__newindex</code><br>
                                <code>if h == nil then rawset(table, key, value); return end</code><br>
                                <code>else</code><br>
                                <code>h = metatable(table).__newindex</code><br>
                                <code>if h == nil then</code><br>
                                <code>mistake(···);</code><br>    
                                <code>end</code><br>
                                <code>end</code><br>
                                <code>if type(h) == "function" then</code><br>
                                <code>h(table, key, value) -- invokes handler</code><br>
                                <code>else h[key] = value -- or repeat the operation with it</code><br>
                                <code>end</code><br>
                                <code>end</code><br>
                            </li>
                            <li>
                                <h4>call</h4>
                                <p>Invoked when Lua calls a value.</p>
                                <code>function function_event(func,...)</code><br>
                                <code>if type(func) == "function" then</code><br>
                                <code>return func(...) -- primitive call</code><br>
                                <code>else</code><br>
                                <code>local h = metatable(func).__call</code><br>
                                <code>if h then</code><br>
                                <code>return h(func, ...)</code><br>
                                <code>else</code><br>
                                <code>mistake(···)</code><br>
                                <code>end</code><br>
                                <code>end</code><br>
                                <code>end</code>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>Environments</h3>
                        <p>In addition to metatables, process type objects, functions and userdata have another associated table, called environment . Like metatables, environments are normal tables and several objects can share the same environment.</p>
                        <p>Environments associated with userdata have no meaning in Lua. It's just a feature for programmers to associate a table with userdata .</p>
                        <p>Environments associated with processes are called global environments . They are used as default environments for processes and for non-nested functions created by the process (via loadfile, loadstringor load) and can be accessed directly by C code.</p>
                        <p>Environments associated with C functions can be accessed directly by C code.</p>
                        <p>They are used as default environments for other C functions created by the given function.</p>
                        <p>The environments associated with functions in Lua are used to resolve all access to global variables within the function. They are also used as default environments for other functions in Lua created by the function.</p>
                        <p>You can change the environment of a Lua function or a running process by invoking setfenv. You can get the environment of a Lua function or the running process by invoking getfenv. To manage the environment of other objects ( userdata , C functions, other processes) you must use the C API.</p>
                    </li>
                    <li>
                        <h3>Release unused memory</h3>
                        <p>Lua automatically performs memory management. This means that we do not have to worry about allocating (or reserving) memory for new objects or freeing it when the objects are no longer needed. Lua manages memory automatically by running a garbage collector from time to time to remove all dead objects (those objects that are no longer accessible from Lua). All objects in Lua are susceptible to automatic management: tables, userdata , functions, processes and strings .</p>
                        <p>Lua implements an incremental mark-sweep memory freer. It uses two numbers to control its memory release cycles: the memory release pause and the memory release step multiplier .</p>
                        <p>The memory cleaner pause controls how long the memory cleaner should wait before starting a new cycle. Large values make the releaser less aggressive. Values less than 1 mean that the releaser will not wait to start a new cycle. A value of 2 means that the releaser waits for the total memory in use to double before starting a new cycle.</p>
                        <p>The step multiplier controls the relative speed of the release in terms of memory allocation. Longer values make the release more aggressive but also increase the size of each incremental step. Values less than 1 make the release too slow and may result in the release never completing a cycle. The default number, 2, means that the freer runs at twice the speed of the memory allocation.</p>
                        <p>You can change those numbers by invoking C a lua_gcor Lua a collectgarbage. Both have a percentage as arguments (and so an argument of 100 means a real value of 1). With these functions you can also control the release directly (for example, stop and restart it).</p>
                        <ul>
                            <li>
                                <h4>Memory release metamethods</h4>
                                <p>Using the C API you can set memory-freeing metamethods for userdata. These metamethods are also called finalizers . These allow you to coordinate Lua's memory release system with external resource managers (such as closing files, network or database connections, or freeing your own memory).</p>
                                <p>Userdata that is to be freed with a field in its metatables__gc is not immediately freed by the memory releaser. Instead Lua puts them in a list. After that Lua does the equivalent of the following function for each userdata in the list:</p>
                                <code>function gc_event (udata)</code><br>
                                <code>local h = metatable(udata).__gc</code><br>
                                <code>if h then</code><br>
                                <code>h(udata)</code><br>
                                <code>end</code><br>
                                <code>end</code>
                                <p>At the end of each memory free cycle, the userdata finalizers that appear in the list to be freed are invoked in the reverse order of their creation. That is, the first finalizer to be invoked is the one associated with the userdata last created by the program. The userdata itself can be freed only in the next memory free cycle.</p>
                            </li>
                            <li>
                                <h4>Weak tables</h4>
                                <p>A weak table is a table whose elements are weak references . A weak reference is ignored by the memory releaser. In other words, if the only references to an object are weak references then the memory associated with this object is freed.</p>
                                <p>A weak table can have weak keys, weak values, or both. A table with weak keys allows the release of its keys, but prohibits the release of its values. A table with weak keys and weak values allows the release of both keys and values. In either case, whether it is the key or the value that is released, the entire pair is removed from the table. The weakness of a table is controlled by the field __modeof its metatable. If the field __modeis a string containing the ' k' character, the keys in the table are weak. If __modeit contains ' v', the values in the table are weak.</p>
                                <p>After using a table as a metatable, the value of its field should not be changed __mode. Otherwise the weak behavior of the tables controlled by that metatable is undefined.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>coroutines</h3>
                        <p>Lua has coroutines, also called collaborative multithreading . In Lua a coroutine represents an independent execution process. Unlike multithreaded systems , in Lua a coroutine only suspends its execution by explicitly invoking a yield function .</p>
                        <p>Coroutines can be created with a call to coroutine.create. The only argument to this function is another function that is the main function of the coroutine.</p>
                        <p>When you call for the first time coroutine.resume, passing as an argument the process returned by coroutine.create, the coroutine begins to execute on the first line of its main function. The extra arguments passed to coroutine.resumeare in turn passed to the main function of the coroutine. After the coroutine begins to execute, it does so until it terminates or a transfer of program flow control occurs.</p>
                        <p>A coroutine can terminate its execution in two ways: normally, when its main function returns (explicitly or implicitly, after its last instruction); and abnormally, if an unprotected error occurred. In the first case, coroutine.resumeit returns true , plus any value returned by the coroutine's main function. In case of error coroutine.resumeit returns false plus an error message.</p>
                        <p>A coroutine gives up control by invoking coroutine.yield. When a coroutine gives up control, the corresponding one coroutine.resumereturns immediately, even if the transfer occurs within a call to a nested function (that is, not in the main function, but in a function directly or indirectly invoked from the main function). In the case of a transfer, coroutine.resumeit also returns true , plus any values passed to coroutine.yield. The next time the same coroutine is resumed, it will continue execution from the point at which the assignment was made, with the call to coroutine.yieldreturning any extra arguments passed to coroutine.resume.</p>
                        <p>The function coroutine.wrapcreates a coroutine, just as it would coroutine.create, but instead of returning the coroutine itself, it returns a function that, when called, summarizes the coroutine. Any arguments passed to this function are passed as arguments to coroutine.resume. coroutine.wrapreturns all the values returned by coroutine.resume, except the first one (the boolean error code). Unlike coroutine.resume, coroutine.wrapit does not capture errors; any errors are propagated to the calling routine.</p>
                        <p>As an example, consider the following code:</p>
                        <code>function foo (a)</code><br>
                        <code>print("foo", a)</code><br>
                        <code>return coroutine.yield(2*a)</code><br>
                        <code>end</code><br>
                        <br>
                        <code>co = coroutine.create(function (a,b)</code><br>
                        <code>print("co-body", a, b)</code><br>
                        <code>local r = foo(a+1)</code><br>
                        <code>print("co-body", r)</code><br>
                        <code>local r, s = coroutine.yield(a+b, ab)</code><br>
                        <code>print("co-body", r, s)</code><br>
                        <code>return b, "end"</code><br>
                        <code>end)</code><br>
                        <br>
                        <code>print("main", coroutine.resume(co, 1, 10))</code><br>
                        <code>print("main", coroutine.resume(co, "r"))</code><br>
                        <code>print("main", coroutine.resume(co, "x", "y"))</code><br>
                        <code>print("main", coroutine.resume(co, "x", "y"))</code>
                        <p>When executed the following output is produced:</p>
                        <code>co-body 1 10</code><br>
                        <code>foo 2</code><br>
                        <code>main true 4</code><br>
                        <code>co-body r</code><br>
                        <code>main true 11 -9</code><br>
                        <code>co-body xy</code><br>
                        <code>main true 10 end</code><br>
                        <code>main false cannot resume dead coroutine</code>
                    </li>
                </ol>
            </section>
            <section class="main-section" id="interface">
                <header>The application program interface (API)</header>
                <p>This section describes the C API for Lua, that is, the set of C functions available for the host program to communicate with Lua. All API functions and their related types and constants are declared in the header file lua.h.</p>
                <p>Although the term "function" is used, some routines in the API can be macros. All of those macros use each of their arguments exactly once (except their first argument, which is always the Lua state), and thus generate no hidden side effects.</p>
                <p>As in most C libraries, Lua's API functions do not check the validity or consistency of their arguments. However, you can change this behavior by compiling Lua with the appropriate definitions for the macro luai_apicheckin the luaconf.h.</p>
                <ol>
                    <li>
                        <h3>The stack</h3>
                        <p>Lua uses a virtual stack to pass values to and from C. Each element on this stack represents a Lua value ( nil , number, string , etc.).</p>
                        <p>Whenever Lua calls C, the called function gets a new stack, which is independent of the previous stacks and the stacks of the C functions that are still active. This stack initially contains any arguments of the C function and is where it places the results that must be returned to the calling routine (see lua_CFunction).</p>
                        <p>For convenience, most API request operations do not follow strict stack discipline. Instead they can refer to any element on the stack using an index : a positive value represents an absolute position on the stack (starting at 1); a negative value represents an offset relative to the top of the stack. More specifically, if the stack has n elements, then index 1 represents the first element (that is, the element that was placed on the stack first) and index n represents the last element; an index -1 also represents the last element (that is, the element at the top) and an index -n represents the first element. We say that an index is valid if it has a value between 1 and the top of the stack (that is, if 1 ≤ abs(índice) ≤ top).</p>
                    </li>
                    <li>
                        <h3>The size of the stack</h3>
                        <p>When the programmer interacts with the Lua API he is responsible for ensuring consistency. In particular it is responsible for controlling the correct growth of the stack . The function can be used lua_checkstackto grow the stack size.</p>
                        <p>Whenever Lua calls C, it makes sure that there are at least LUA_MINSTACKavailable positions on the stack. LUA_MINSTACKis defined as 20, so normally the programmer does not have to worry about stack space, unless his code has loops that push elements onto the stack.</p>
                        <p>Most request functions accept as an index any value within the available space on the stack, that is, indexes up to the maximum stack size established by lua_checkstack. These indices are called acceptable indices . More formally, we define an acceptable index as follows:</p>
                        <code> (index &lt; 0 && abs(index) &lt;= top) ||</code><br>
                        <code>(index > 0 && index &lt;= stackspace)</code>
                        <p>Note that 0 is never an acceptable index.</p>
                    </li>
                    <li>
                        <h3>Pseudoindexes</h3>
                        <p>Except where noted, any function that accepts valid indexes can also be called with pseudoindexes , which represent some values in Lua that are accessible from the C code but are not on the stack. Pseudoindexes are used to access the process environment, the function environment, the register and the upvalues of a C function (see §3.4 ).</p>
                        <p>The process environment (where global variables "live") is always in the pseudoindex LUA_GLOBALSINDEX. The environment of a C function that is running is always at pseudoindex LUA_ENVIRONINDEX.</p>
                        <p>To access and change the value of a global variable, you can use normal table operations on the environment table. For example, to access the value of a global variable you do</p>
                        <code>lua_getfield(L, LUA_GLOBALSINDEX, global_variable_name);</code>
                    </li>
                    <li>
                        <h3>Instances in C</h3>
                        <p>When a C function is created it is possible to associate some values to it, creating an instance in C ; These values are called upvalues and are accessible to the function any time it is called (see lua_pushcclosure).</p>
                        <p>Whenever a C function is called, its upvalues are located at specific pseudoindexes. These are produced using the macro lua_upvalueindex. The first value associated with a function is at position lua_upvalueindex(1), and so on. Any access to , where n is greater than the number of upvalues of the current function produces an acceptable but invalid index.lua_upvalueindex(n)</p>
                    </li>
                    <li>
                        <h3>Registration</h3>
                        <p>Lua provides a register , a predefined table that can be used by any C code to store any value that Lua needs to store. This table is always located in the pseudoindex LUA_REGISTRYINDEX. Any C library can store data in this table, but you should be careful to choose different keys from those used by other libraries, to avoid conflicts. Typically a string containing the name of the library or "lightweight" userdata with the address of a C object in the code could be used as a key .</p>
                        <p>The integer type keys in the registry are used as a referencing mechanism, implemented in the auxiliary library, and therefore should not be used for other purposes.</p>
                    </li>
                    <li>
                        <h3>Error handling in C</h3>
                        <p>Internally Lua uses the C function longjmpto facilitate error handling. (You can also choose to use exceptions directly if working in C++; see file luaconf.h.) When Lua encounters any error (such as a memory allocation error, a type error, a syntax error, or a runtime error ) then triggers an error, that is, it performs a long jump in memory. A protected environment is used setjmpto establish a recovery point; any failure causes a jump to the most recent active recovery point.</p>
                        <p>Many API functions can trigger an error, for example due to a memory allocation problem. The documentation for each function indicates whether it can trigger a bug.</p>
                        <p>Within a C function an error can be triggered by invoking lua_error.</p>
                    </li>
                    <li>
                        <h3>Functions and types</h3>
                        <p>Here is the list of all C API functions and types in alphabetical order. Each function has a flag like this:[-o, +p, x ]</p>
                        <p>The first field, o, indicates how many elements the function removes from the stack. The second field, p, is how many elements the function places on the stack. (Every function always places its results after removing its arguments.) A form field x|ymeans that the function can place (or remove) xor yelements, depending on the situation; a question mark ' ?' means that you cannot know how many elements the function places/removes by looking only at its arguments (for example, it may depend on what is on the stack). The third, field x, indicates whether the function can trigger errors: ' -' means that the function never triggers errors; ' m' indicates that the function may trigger an error only due to lack of memory; ' e' indicates that the function can trigger other types of errors; ' v' indicates that the function may trigger an error on purpose.</p>
                        <ul>
                            <li>
                                <h4>lua_Alloc</h4>
                                <code>typedef void * (*lua_Alloc) (void *ud,</code>
                                <code>void *ptr,</code><br>
                                <code>size_t osize,</code><br>
                                <code>size_t nsize);</code>
                                <p>The type of the function that manages the memory used by Lua states. The function that manages memory must provide functionality similar to realloc, but not exactly the same. Its arguments are: ud, an opaque pointer passed to lua_newstate; ptr, a pointer to the block being reserved/reallocated/released; osize, the original size of the block; nsize, the new block size. ptris NULLif and only if osizeit is zero. When nsizeit is zero, the handler should return NULL; If osizeit is not zero, the block pointed to by must be released ptr. When nsizeit is not zero the handler returns NULLif and only if it cannot execute the request. When nsizeit is not zero and osizeit is zero the handler should behave like malloc. When nsizeand osizeare not zero, the handler behaves like realloc. Lua assumes that the handler never fails when osize >= nsize.</p>
                                <p>Here is a simple implementation for the memory manager function. It is used in the auxiliary library by lua_newstate.</p>
                                <code>static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {</code><br>
                                <code>(void) u; (void)osize; /* not used */</code><br>
                                <code>if (nsize == 0) {</code><br>
                                <code>free(ptr);</code><br>
                                <code>return NULL;</code><br>
                                <code>}</code><br>
                                <code>else</code><br>
                                <code>return realloc(ptr, nsize);</code><br>
                                <code>}</code>
                                <p>This code assumes that free(NULL)it has no effect and realloc(NULL, size)is equivalent to malloc(size). ANSI C ensures both behaviors.</p>
                            </li>
                            <li>
                                <h4>lua_atpanic</h4>
                                <code>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</code>
                                <p>Set a new panic function and return the old one.</p>
                                <p>If an error occurs outside of any protected environment Lua calls the panic function and then invokes exit(EXIT_FAILURE), thereby exiting the host application. If you use a different panic function, it can prevent this exit without return (for example, by doing a long jump).</p>
                                <p>The panic function can access the error message at the top of the stack.</p>
                            </li>
                            <li>
                                <h4>lua_call</h4>
                                <code>void lua_call (lua_State *L, int nargs, int nresults);</code><br>
                                <code>Call a function.</code>
                                <p>To call a function, the following protocol must be used: first, the function to be called is placed on the top of the stack; then, the function arguments are also placed on the stack in direct order; that is, the first argument is placed first. Finally, we call lua_call; nargsis the number of arguments that have been placed on the stack. All arguments and the value of the function are removed from the stack when the function is called. The results of the function are placed on top of the stack when the function returns. The number of results is set to nresults, unless nresultsit is LUA_MULTRET. In this case all the results of the function are placed . Lua takes care that the returned values fit into the stack space. The results of the function are placed on the stack in direct order (the first is placed first), so after the call the last result appears at the top of the stack.</p>
                                <p>Any errors within the called function are propagated backwards (with a longjmp).</p>
                                <p>The following example shows how the host program can do something equivalent to this code in Lua:</p>
                                <code>a = f("how", tx, 14)</code>
                                <p>Here it is in C:</p>
                                <code>lua_getfield(L, LUA_GLOBALSINDEX, "f"); /* function that is called */</code><br>
                                <code>lua_pushstring(L, "how"); /* first argument */</code><br>
                                <code>lua_getfield(L, LUA_GLOBALSINDEX, "t"); /* table that is indexed */</code><br>
                                <code>lua_getfield(L, -1, "x"); /* put tx on stack (2nd argument) */</code><br>
                                <code>lua_remove(L, -2); /* remove 't' from the stack */</code><br>
                                <code>lua_pushinteger(L, 14); /* 3rd argument */</code><br>
                                <code>lua_call(L, 3, 1); /* calls the function with 3 arguments and 1 result */</code><br>
                                <code>lua_setfield(L, LUA_GLOBALSINDEX, "a"); /* modifies the global variable 'a' */</code>
                                <p>Keep in mind that the code above is "balanced" at the end, since the stack has returned to its initial configuration. This is considered good programming practice.</p>
                            </li>
                            <li>
                                <h4>lua_CFunction</h4>
                                <code>typedef int (*lua_CFunction) (lua_State *L);</code><br>
                                <code>Type for C functions.</code>
                                <p>In order to communicate properly with Lua, a C function must use the following protocol, which defines the way in which arguments and results are passed: A C function receives its arguments from Lua on its stack in direct order (the first argument is placed first). Therefore, when a function starts, lua_gettop(L)it returns the number of arguments received by the function. Its first argument (if it exists) is at index 1 and its last argument is at index lua_gettop(L). To return values to Lua, a C function just places them on the stack, in direct order (first result goes first), and returns the number of results. Any other values on the stack below the results must be properly discarded by Lua. Like a Lua function, a C function called from Lua can return multiple results.</p>
                                <p>As an example, the following function takes a variable number of numeric arguments and returns their mean and sum:</p>
                                <code>static int foo (lua_State *L) {</code><br>
                                <code>int n = lua_gettop(L); /* number of arguments */</code><br>
                                <code>lua_Number sum = 0;</code><br>
                                <code>int i;</code><br>
                                <code>for (i = 1; i &lt;= n; i++) {</code><br>
                                <code>if (!lua_isnumber(L, i)) {</code><br>
                                <code>lua_pushstring(L, "wrong argument in function 'media'");</code><br>
                                <code>lua_error(L);</code><br>
                                <code>}</code><br>
                                <code>sum += lua_tonumber(L, i);</code><br>
                                <code>}</code><br>
                                <code>lua_pushnumber(L, sum/n); /* first result */</code><br>
                                <code>lua_pushnumber(L, sum); /* second result */</code><br>
                                <code>return 2; /* number of results */</code><br>
                                <code>}</code>
                            </li>
                            <li>
                                <h4>lua_checkstack</h4>
                                <code>int lua_checkstack (lua_State *L, int extra);</code>
                                <p>It ensures that there are at least extrafree positions on the stack. Returns falseif it cannot grow the stack to that size. This function never decreases the stack; If the stack is already larger than the new size, it leaves it unchanged.</p>
                            </li>
                            <li>
                                <h4>lua_close</h4>
                                <code>void lua_close (lua_State *L);</code>
                                <p>Destroys all objects in the given Lua state (by calling the corresponding free memory metamethod, if it exists) and frees all dynamic memory used by this state. On some platforms it may not be necessary to call this function, because all resources are naturally freed when the host program terminates. On the other hand, long-running programs, such as a web server daemon , may need to release states as soon as they are not needed to avoid excessive growth.</p>
                            </li>
                            <li>
                                <h4>lua_concat</h4>
                                <code>void lua_concat (lua_State *L, int n);</code>
                                <p>Concatenates the nvalues at the top of the stack, removes them, and leaves the result at the top of the stack. If nit is 1 the result is the single value on the stack (that is, the function does nothing); if nit is 0 the result is an empty string . Concatenation is done following normal Lua semantics.</p>
                            </li>
                            <li>
                                <h4>lua_cpcall</h4>
                                <code>int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);</code>
                                <p>Invokes the C function funcin protected mode. funcIt starts with a single element on its stack, a lightweight userdata containing ud. On errors lua_cpcallit returns the same error code as lua_pcall, plus the error object at the top of the stack; Otherwise it returns zero and does not change the stack. All values returned by funcare discarded.</p>
                            </li>
                            <li>
                                <h4>lua_createtable</h4>
                                <code>void lua_createtable (lua_State *L, int narr, int nrec);</code>
                                <p>Creates a new empty table and puts it on the stack. The new table has space reserved for arraynarr elements and non-array elements . This reservation is useful when you do not know how many elements the table will contain. In another case you can use the function .nreclua_newtable</p>
                            </li>
                            <li>
                                <h4>lua_dump</h4>
                                <code>int lua_dump (lua_State *L, lua_Writer writer, void *data);</code>
                                <p>Dumps a function in the form of a binary chunk . Receives a Lua function at the top of the stack and produces a binary chunk that if loaded again results in a function equivalent to the previously dumped one. As it produces parts of the chunk , lua_dumpit invokes the function writer(see lua_Writer) with the data datato write it.</p>
                                <p>The return value is the error code returned by the last call to Writer; 0 means no error.</p>
                                <p>This function does not remove the Lua function from the stack.</p>
                            </li>
                            <li>
                                <h4>lua_equal</h4>
                                <code>int lua_equal(lua_State *L, int index1, int index2);</code>
                                <p>Returns 1 if the two values at the acceptable indices index1e are equal, following Lua index2operator semantics (that is, it can invoke metamethods). ==Otherwise it returns 0. It also returns 0 if any of the indexes are invalid.</p>
                            </li>
                            <li>
                                <h4>lua_error</h4>
                                <code>int lua_error (lua_State *L);</code>
                                <p>Generates a Lua error. The error message (which can actually be a Lua value of any type) should be at the top of the stack. This function performs a long jump, and therefore never returns. (see luaL_error).</p>
                            </li>
                            <li>
                                <h4>lua_gc</h4>
                                <code>int lua_gc (lua_State *L, int what, int data);</code>
                                <p>Check the memory release.</p>
                                <p>This function performs several tasks, according to the value of the argument what:</p>
                                <ul>
                                    <li>
                                        <h5>LUA_GCSTOP</h5>
                                        <p>stops the memory cleanup.</p>
                                    </li>
                                    <li>
                                        <h5>LUA_GCRESTART</h5>
                                        <p>restart the memory cleaner.</p>
                                    </li>
                                    <li>
                                        <h5>LUA_GCCOLLECT</h5>
                                        <p>performs a complete memory release cycle.</p>
                                    </li>
                                    <li>
                                        <h5>LUA_GCCOUNT</h5>
                                        <p>returns the current amount of memory (in Kbytes) in use by Lua.</p>
                                    </li>
                                    <li>
                                        <h5>LUA_GCCOUNTB</h5>
                                        <p>returns the remainder of dividing by 1024 the current amount of memory in bytes in use by Lua.</p>
                                    </li>
                                    <li>
                                        <h5>LUA_GCSTEP</h5>
                                        <p>performs an incremental memory release step. The "size" of the step is controlled by data(a larger value means more steps) in an unspecified way. If you want to control the step size, you must experimentally tune the value of data. The function returns 1 if the step ended with a memory release cycle.</p>
                                    </li>
                                    <li>
                                        <h5>LUA_GCSETPAUSE</h5>
                                        <p>sets data/100 as the new memory clearer pause value (see §2.10 ). The function returns the previous value of the pause.</p>
                                    </li>
                                    <li>
                                        <h5>LUA_GCSETSTEPMUL</h5>
                                        <p>sets data/100 as the new memory clearer step multiplier value (see §2.10 ). The function returns the previous value of the multiplier.</p>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <h4>lua_getallocf</h4>
                                <code>lua_Alloc lua_getallocf (lua_State *L, void **ud);</code>
                                <p>Returns the memory manager function of a given state. If udnot NULLLua saves in *udthe opaque pointer passed to lua_newstate.</p>
                            </li>
                            <li>
                                <h4>lua_getfenv</h4>
                                <code>void lua_getfenv (lua_State *L, int index);</code>
                                <p>Pushes the environment table of a value at the given index onto the stack.</p>
                            </li>
                            <li>
                                <h4>lua_getfield</h4>
                                <code>void lua_getfield (lua_State *L, int index, const char *k);</code>
                                <p>Places the value on the stack t[k], where tis the value given by the valid index. As in Lua this function can trigger a metamethod for the "index" event.</p>
                            </li>
                            <li>
                                <h4>lua_getglobal</h4>
                                <code>void lua_getglobal (lua_State *L, const char *name);</code>
                                <p>Places the value of the nombreglobal on the stack. It is defined as a macro:</p>
                                <code>#define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, s)</code>
                            </li>
                            <li>
                                <h4>lua_getmetatable</h4>
                                <code>int lua_getmetatable (lua_State *L, int index);</code>
                                <p>Places the metatable of the value at the given acceptable index onto the stack. If the index is invalid or if the value does not have a metatable, the function returns 0 and does not push anything onto the stack.</p>
                            </li>
                            <li>
                                <h4>lua_gettable</h4>
                                <code>void lua_gettable (lua_State *L, int index);</code>
                                <p>Pushes the value onto the stack t[k], where tis the value at the valid index and kis the value at the top of the stack.</p>
                                <p>This function removes the key from the top of the stack (placing the resulting value in its place). As in Lua this function can trigger a metamethod for the "index" event.</p>
                            </li>
                            <li>
                                <h4>lua_gettop</h4>
                                <code>int lua_gettop(lua_State *L);</code>
                                <p>Returns the index of the element at the top of the stack. Because indexes start at 1 this result is equal to the number of elements on the stack (and so 0 means an empty stack).</p>
                            </li>
                            <li>
                                <h4>lua_insert</h4>
                                <code>void lua_insert (lua_State *L, int index);</code>
                                <p>Moves the element at the top of the stack to the given valid index, moving up elements above this index to make room. It cannot be called with a pseudoindex because this is not a real position on the stack.</p>
                            </li>
                            <li>
                                <h4>lua_Integer</h4>
                                <code>typedef ptrdiff_t lua_Integer;</code>
                                <p>The type used by the Lua API to represent integer values.</p>
                                <p>The default is ptrdiff_t, which is normally the largest signed integer type that the machine "comfortably" handles.</p>
                            </li>
                            <li>
                                <h4>lua_isboolean</h4>
                                <code>int lua_isboolean (lua_State *L, int index);</code>
                                <p>Returns 1 if the value in the acceptable index situation has type boolean and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_iscfunction</h4>
                                <code>int lua_iscfunction (lua_State *L, int index);</code>
                                <p>Returns 1 if the value in the acceptable index situation is a C function and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_isfunction</h4>
                                <code>int lua_isfunction (lua_State *L, int index);</code>
                                <p>Returns 1 if the value in the acceptable index situation is a function (in C or Lua) and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_islightuserdata</h4>
                                    <code>int lua_islightuserdata (lua_State *L, int index);</code>
                                    <p>Returns 1 if the value in the acceptable index situation is a lightweight userdata and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_isnil</h4>
                                <code>int lua_isnil (lua_State *L, int index);</code>
                                <p>Returns 1 if the value in the acceptable index situation is nil and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_isnone</h4>
                                <code>int lua_isnone (lua_State *L, int index);</code>
                                <p>Returns 1 if the value in the acceptable index situation is invalid (that is, if it refers to an element outside the current stack) and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_isnoneornil</h4>
                                <code>int lua_isnoneornil (lua_State *L, int index);</code>
                                <p>Returns 1 if the value at the acceptable index location is invalid (that is, if it refers to an element outside the current stack) or if the value at this index is nil, and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_isnumber</h4>
                                <code>int lua_isnumber (lua_State *L, int index);</code>
                                <p>Returns 1 if the value in the acceptable index situation is a number or a string convertible to a number and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_isstring</h4>
                                <code>int lua_isstring (lua_State *L, int index);</code>
                                <p>Returns 1 if the value in the acceptable index situation is a string or a number (which is always convertible to a string ) and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_istable</h4>
                                <code>int lua_istable (lua_State *L, int index);</code>
                                <p>Returns 1 if the value in the acceptable index situation is a table and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_isthread</h4>
                                <code>int lua_isthread (lua_State *L, int index);</code>
                                <p>Returns 1 if the value in the acceptable index situation is a process and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_isuserdata</h4>
                                <code>int lua_isuserdata (lua_State *L, int index);</code>
                                <p>Returns 1 if the value in the acceptable index situation is a userdata (light or full) and 0 otherwise.</p>
                            </li>
                            <li>
                                <h4>lua_lessthan</h4>
                                <code>int lua_lessthan (lua_State *L, int index1, int index2);</code>
                                <p>Returns 1 if the value at the acceptable index position index1is less than the value at the acceptable index position , following Lua index2operator semantics (that is, it can invoke metamethods). &lt;Otherwise it returns 0. It also returns 0 if any of the indexes are invalid.</p>
                            </li>
                            <li>
                                <h4>lua_load</h4>
                                <code>int lua_load (lua_State *L,</code><br>
                                <code>lua_Reader reader,</code><br>
                                <code>void *data,</code><br>
                                <code>const char *chunkname);</code>
                                <p>Load a Lua chunk . If there are no errors, lua_loadit pushes the compiled chunk to the top of the stack. Otherwise, place an error message there. The return values of lua_loadare:</p>
                                <ul>
                                    <li>
                                        <h5>0</h5>
                                        <p>no errors.</p>
                                    </li>
                                    <li>
                                        <h5>LUA_ERRSYNTAX</h5>
                                        <p>syntax error during precompilation.</p>
                                    </li>
                                    <li>
                                        <h5>LUA_ERRMEM</h5>
                                        <p>memory reservation error.</p>
                                    </li>
                                </ul>
                                <p>lua_loadIt automatically detects whether the chunk is in binary or text form, and loads it accordingly (see program luac).</p>
                                <p>lua_loadlectorauses a user-supplied function to read the chunk (see lua_Reader). The argument datais an opaque value passed to the reader function.</p>
                                <p>The argument chunknamegives a name to the chunk . which is used in error messages and debugging information.</p>
                            </li>
                            <li>
                                <h4>lua_newstate</h4>
                                <code>lua_State *lua_newstate (lua_Alloc f, void *ud);</code>
                                <p>Create a new independent state. Returns NULLif it cannot create the state (due to lack of memory). The argument fis the memory reservation function; Lua does all the memory reservation for this state through this function. The second argument, ud, is an opaque pointer that Lua simply passes to the memory allocator on each call.</p>
                            </li>
                            <li>
                                <h4>lua_newtable</h4>
                                <code>void lua_newtable (lua_State *L);</code>
                                <p>Creates a new empty table and puts it on the stack. Equals lua_createtable(L, 0, 0).</p>
                            </li>
                            <li>
                                <h4>lua_newthread</h4>
                                <code>lua_State *lua_newthread (lua_State *L);</code>
                                <p>Creates a new process, pushes it onto the stack, and returns a pointer to a process lua_Statethat represents this new process. The new state returned by this function shares all global objects (such as tables) with the original, but has a separate execution stack.</p>
                                <p>There is no explicit function to close or destroy a process. Processes are subject to memory release, like any other Lua object.</p>
                            </li>
                            <li>
                                <h4>lua_newuserdata</h4>
                                <code>void *lua_newuserdata (lua_State *L, size_t size);</code>
                                <p>This function reserves a new memory block with the given size, pushes a new userdata complete with the address of the memory block onto the stack, and returns this address.</p>
                                <p>Userdata represent C values in Lua. A complete userdata represents a block of memory. It is an object (like a table): it can be created, it can have its own metatable, and it can detect when it is being removed from memory. A complete userdata is only equal to itself (in a direct equality test).</p>
                                <p>When Lua frees an entire userdata with a metamethod gc, it calls the metamethod and marks the userdata as finished. When this userdata is freed again, Lua definitively frees the corresponding memory.</p>
                            </li>
                            <li>
                                <h4>lua_next</h4>
                                <code>int lua_next (lua_State *L, int index);</code>
                                <p>Removes a key from the stack and places a key-value pair from a table at the given index (the "next" pair after the given key). If there are no more elements in the table then lua_nextit returns 0 (and puts nothing on the stack).</p>
                                <p>A typical table traversal iteration would be:</p>
                                <code>/* the table is on the stack at index 't' */</code><br>
                                <code>lua_pushnil(L); /* first key */</code><br>
                                <code>while (lua_next(L, t) != 0) {</code><br>
                                <code>/* 'key' is at index -2 and 'value' is at index -1 */</code><br>
                                <code>printf("%s - %s\n",</code><br>
                                <code>lua_typename(L, lua_type(L, -2)),</code><br>
                                <code>lua_typename(L, lua_type(L, -1)));</code><br>
                                <code>/* remove 'value'; keeps 'key' for next iteration */</code><br>
                                <code>lua_pop(L, 1);</code><br>
                                <code>}</code>
                                <p>While traversing a table you should not call lua_tolstringdirectly on a key unless you know that the key is actually a string . Remember that it changes the value at the given index; this confuses the next call to .lua_tolstring lua_next</p>
                            </li>
                            <li>
                                <h4>lua_Number</h4>
                                <code>typedef double lua_Number;</code>
                                <p>The type of numbers in Lua. By default it is a double, but it can be changed to luaconf.h.</p>
                                <p>Through the configuration file you can change Lua to operate with other types of numbers (for example, floator long).</p>
                            </li>
                            <li>
                                <h4>lua_objlen</h4>
                                <code>size_t lua_objlen (lua_State *L, int index);</code>
                                <p>Returns the "length" of a value located at the acceptable index: for a string , it is its length; for a table, it is the result of the length operator (' #'); for a userdata , it is the size of the memory block reserved for it; for other values it is 0.</p>
                            </li>
                            <li>
                                <h4>lua_pcall</h4>
                                <code>int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);</code>
                                <p>Invokes a function in protected mode.</p>
                                <p>As much nargsas nresultsthey have the same meaning as in lua_call. If there are no errors during the call, lua_pcallit behaves exactly the same as lua_call. However, in case of an error lua_pcallit catches it, placing a single value on the stack (the error message) and returns an error code. Like lua_call, lua_pcallalways removes the function and its arguments from the stack.</p>
                                <p>If errfuncit is 0 then the error message returned on the stack is exactly the original message. Otherwise, errfuncit is the index on the stack of an error handler function . (In the current implementation, this index cannot be a pseudoindex.) In case of execution errors this function will be called with the error message and the returned value will be the message returned on the stack by lua_pcall.</p>
                                <p>Typically the error handler function is used to add more debugging information to the error message, such as a "back trace" of the stack. That information cannot be collected after the return of lua_pcall, since by then the stack no longer has that information.</p>
                                <p>The function lua_pcallreturns 0 on success or one of the following error codes (defined in lua.h):</p>
                                <ul>
                                    <li>
                                        <h5>LUA_ERRRUN</h5>
                                        <p>an execution error.</p>
                                    </li>
                                    <li>
                                        <h5>LUA_ERRMEM</h5>
                                        <p>a memory reservation error. For this error Lua does not call the error handler function.</p>
                                    </li>
                                    <li>
                                        <h5>LUA_ERRERR</h5>
                                        <p>error while the error handler function is being executed.</p>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <h4>lua_pop</h4>
                                <code>void lua_pop (lua_State *L, int n);</code>
                                <p>Removes nelements from the stack.</p>
                            </li>
                            <li>
                                <h4>lua_pushboolean</h4>
                                <code>void lua_pushboolean (lua_State *L, int b);</code>
                                <p>Push the boolean value bonto the stack.</p>
                            </li>
                            <li>
                                <h4>lua_pushcclosure</h4>
                                <code>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</code>
                                <p>Place a new C instance on the stack.</p>
                                <p>When a C function is created it is possible to associate some values to it, thus creating an instance in C (see §3.4 ); These values are then accessible to the function any time it is invoked. To associate values with a C function, they should first be placed on the stack (when there are several, the first one is placed first). It is then called lua_pushcclosureto create and place the C function on the stack, with the argument nindicating how many values are associated with it. lua_pushcclosurealso removes those values from the stack.</p>
                            </li>
                            <li>
                                <h4>lua_pushcfunction</h4>
                                <code>void lua_pushcfunction (lua_State *L, lua_CFunction f);</code>
                                <p>Place a C function on the stack. This function receives a pointer to a C function and places a Lua value of type on the stack, functionwhich, when called, invokes the corresponding C function.</p>
                                <p>Any function that is registered in Lua must follow the correct protocol to receive its arguments and return its results (see lua_CFunction).</p>
                                <p>lua_pushcfunction(L, f)is defined as a macro:</p>
                                <code>#define lua_pushcfunction(L, f) lua_pushcclosure(L, f, 0)</code>
                            </li>
                            <li>
                                <h4>lua_pushfstring</h4>
                                <code>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</code>
                                <p>Places a formatted string on the stack and returns a pointer to this string . It is similar to the sprintfC function, but has some important differences:</p>
                                <ul>
                                    <li>
                                        <p>You don't have to reserve memory for the result, since the result is a Lua string , and Lua takes care of reserving (and releasing) memory.</p>
                                    </li>
                                    <li>
                                        <p>The conversion specifiers are quite restrictive. There are no indicators, widths or precisions. Conversion specifiers can only be: ' %%' (insert a ' %' into the string ), ' %s' (insert a zero-terminated string with no size restrictions), ' %f' (insert a lua_Number), ' %p' (insert a pointer as a number hexadecimal), ' %d' (insert a int), and ' %c' (insert a intas character).</p>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <h4>lua_pushinteger</h4>
                                <code>void lua_pushinteger (lua_State *L, lua_Integer n);</code>
                                <p>Places an integer value non the stack.</p>
                            </li>
                            <li>
                                <h4>lua_pushlightuserdata</h4>
                                <code>void lua_pushlightuserdata (lua_State *L, void *p);</code>
                                <p>Put a lightweight userdata on the stack.</p>
                                <p>Userdata represent C values in Lua. A lightweight userdata represents a pointer. It is a value (like a number): it is not created or has metatables and does not suffer memory release (since it was never reserved). In an equality comparison, a lightweight userdata is the same as any other lightweight userdata with the same address in C.</p>
                            </li>
                            <li>
                                <h4>lua_pushliteral</h4>
                                <code>void lua_pushliteral (lua_State *L, const char *s);</code>
                                <p>This macro is equivalent to lua_pushlstring, but can be used only when sit is a string literal. In those cases, it automatically provides the length of the string</p>
                            </li>
                            <li>
                                <h4>lua_pushlstring</h4>
                                <code>void lua_pushlstring (lua_State *L, const char *s, size_t len);</code>
                                <p>Places the string pointed to by swith size lenon the stack. Lua makes (or reuses) an internal copy of the given string , so the memory in it scan be freed or reused immediately after the function returns. The string can contain zeros.</p>
                            </li>
                            <li>
                                <h4>lua_pushnil</h4>
                                <code>void lua_pushnil (lua_State *L);</code>
                                <p>Put a nil value on the stack.</p>
                            </li>               
                            <li>
                                <h4>lua_pushnumber</h4>
                                <code>void lua_pushnumber (lua_State *L, lua_Number n);</code>
                                <p>Place a number with value non the stack.</p>
                            </li>
                            <li>
                                <h4>lua_pushstring</h4>
                                <code>void lua_pushstring (lua_State *L, const char *s);</code>
                                <p>Places the zero-terminated string it points to son the stack. Lua makes (or reuses) an internal copy of the given string , so the memory in it scan be freed or reused immediately after the function returns. The string cannot contain zero characters; It is assumed that the end of it is the first zero character that appears.</p>
                            </li>
                            <li>
                                <h4>lua_pushthread</h4>
                                <code>int lua_pushthread (lua_State *L);</code>
                                <p>Places a process represented by Lon the stack. Returns 1 if this process is the parent process of its state.</p>
                            </li>
                            <li>
                                <h4>lua_pushvalue</h4>
                                <code>void lua_pushvalue (lua_State *L, int index);</code>
                                <p>Places a copy of the element at the given valid index onto the stack.</p>
                            </li>
                            <li>
                                <h4>lua_pushvfstring</h4>
                                    <code>const char *lua_pushvfstring (lua_State *L,</code><br>
                                    <code>const char *fmt,</code><br>
                                    <code>va_list argp);</code>
                                    <p>Equivalent to lua_pushfstring, except that it takes one type argument va_listinstead of a variable number of arguments.</p>
                            </li>
                            <li>
                                <h4>lua_rawequal</h4>
                                    <code>int lua_rawequal(lua_State *L, int index1, int index2);</code>
                                    <p>Returns 1 if the two values located at the acceptable indices index1e index2are primitively equal (that is, without invoking metamethods). Otherwise it returns 0. It also returns 0 if any of the indexes are invalid.</p>
                            </li>
                            <li>
                                <h4>lua_rawget</h4>
                                    <code>void lua_rawget (lua_State *L, int index);</code>
                                    <p>Similar to lua_gettable, but performs a shortcut (no metamethods).</p>
                            </li>
                            <li>
                                <h4>lua_rawgeti</h4>
                                    <code>void lua_rawgeti (lua_State *L, int index, int n);</code>
                                    <p>Pushes the value t[n], where tis the value at the valid index, onto the stack. Access is direct, that is, without invoking metamethods.</p>
                            </li>
                            <li>
                                <h4>lua_rawset</h4>
                                    <code>void lua_rawset (lua_State *L, int index);</code>
                                    <p>Similar to lua_settable, but performing a direct assignment (without invoking metamethods).</p>
                            </li>
                            <li>
                                <h4>lua_rawseti</h4>
                                    <code>void lua_rawseti (lua_State *L, int index, int n);</code>
                                    <p>Performs the equivalent of t[n] = v, where tis the value at the valid index and vis the value at the top of the stack.</p>
                                    <p>This function removes the value from the top of the stack. The assignment is direct, without invoking metamethods.</p>
                            </li>
                            <li>
                                <h4>lua_Reader</h4>
                                    <code>typedef const char * (*lua_Reader) (lua_State *L,</code><br>
                                    <code>void *data,</code><br>
                                    <code>size_t *size);</code>
                                    <p>The read function used by lua_load. Every time it needs another piece of chunk , lua_loadit calls the "reader", passing it its argument data. The reader must return a pointer to a block of memory with a new chunk and set it sizeas the size of the block. The block must exist until the reader function is called again. To signal the end of the chunk the reader must return NULL. The reader function can return fragments of any size greater than zero.</p>
                            </li>
                            <li>
                                <h4>lua_register</h4>
                                    <code>void lua_register (lua_State *L,</code><br>
                                    <code>const char *name,</code><br>
                                    <code>lua_CFunction f);</code>
                                    <p>Sets the function C fas the new value of the nombreglobal. It is defined in the macro:</p>
                                    <code>#define lua_register(L,n,f) \</code><br>
                                    <code>(lua_pushcfunction(L, f), lua_setglobal(L, n))</code>
                            </li>
                            <li>
                                <h4>lua_remove</h4>
                                    <code>void lua_remove (lua_State *L, int index);</code>
                                    <p>Removes the element at the position of the given valid index, moving down elements that were above this index to fill the gap. It cannot be called with a pseudoindex, because this is not a real position on the stack.</p>
                            </li>
                            <li>
                                <h4>lua_replace</h4>
                                    <code>void lua_replace (lua_State *L, int index);</code>
                                    <p>Moves the element at the top of the stack to the given position (and removes it from the top of the stack), without moving any element from the stack (thus replacing the value at the given position).</p>
                            </li>
                            <li>
                                <h4>lua_resume</h4>
                                <code>int lua_resume (lua_State *L, int narg);</code>
                                <p>Starts and resumes a coroutine in a given process.</p>
                                <p>To start a coroutine, a new process must be created (see lua_newthread); then the main function plus any possible arguments are placed on its own stack; is subsequently invoked lua_resume, with nargbeing the number of arguments. This call returns when the coroutine suspends or ends its execution. When it returns, the stack contains all the values passed to lua_yield, or all the values returned by the body of the function. lua_resumereturns LUA_YIELDif the coroutine relinquished control, 0 if the coroutine completed its execution without errors, or an error code in case of errors (see lua_pcall). In case of error, information is left on the stack, so you can use the debug API with it. The error message is at the top of the stack. To restart a coroutine, only the values that are passed as a result of yield, are put on the stack, and then , is invoked lua_resume.</p>
                            </li>
                            <li>
                                <h4>lua_setallocf</h4>
                                <code>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</code>
                                <p>Used fwith userdata ud as a memory reservation function for a given state.</p>
                            </li>
                            <li>
                                <h4>lua_setfenv</h4>
                                <code>int lua_setfenv (lua_State *L, int index);</code>
                                <p>Removes a table from the top of the stack and takes it as the new environment for the value at the index position. If the given value is neither a function nor a process nor a userdata then lua_setfenvit returns 0. Otherwise it returns 1.</p>
                            </li>
                            <li>
                                <h4>lua_setfield</h4>
                                <code>void lua_setfield (lua_State *L, int index, const char *k);</code>
                                <p>Performs the equivalent of t[k] = v, where tis the value at the valid index position and vis the value at the top of the stack.</p>
                                <p>This function removes the value from the stack. As in Lua, this function can trigger a metamethod for the "newindex".</p>
                            </li>
                            <li>
                                <h4>lua_setglobal</h4>
                                <code>void lua_setglobal (lua_State *L, const char *name);</code>
                                <p>Removes a value from the stack and takes it as the new nombreglobal value. It is defined in a macro:</p>
                                <code>#define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, s)</code>                                                   
                            </li>
                            <li>
                                <h4>lua_setmetatable</h4>
                                <code>int lua_setmetatable (lua_State *L, int index);</code>
                                <p>Removes a table from the stack and takes it as the new metatable for the value in the acceptable index situation.</p>                  
                            </li>
                            <li>
                                <h4>lua_settable</h4>
                                <code>void lua_settable (lua_State *L, int index);</code>
                                <p>Does the equivalent of t[k] = v, where tis the value at the valid index position, vis the value at the top of the stack, and kis the value just below it.</p>
                                <p>This function removes both the key and the value from the stack. As in Lua, this function can trigger a metamethod for the "newindex" event.</p>                   
                            </li>
                            <li>
                                <h4>lua_settop</h4>
                                <code>void lua_settop (lua_State *L, int index);</code>
                                <p>Accepts any acceptable index or 0 and sets the top of the stack to this index. If that value is greater than the old one then the new elements are padded with nil . If indexit is 0 then all elements on the stack are removed.</p>
                            </li>
                            <li>
                                <h4>lua_State</h4>
                                <code>typedef struct lua_State lua_State;</code>
                                <p>Opaque structure that stores the entire state of a Lua interpreter. The Lua library is completely re-entrant: it has no global variables. All information about a state is stored in this structure.</p>
                                <p>A pointer to this state must be passed as the first argument to any function in the library, except lua_newstate, which creates a new Lua state from scratch.</p>
                            </li>
                            <li>
                                <h4>lua_status</h4>
                                <code>int lua_status (lua_State *L);</code>
                                <p>Returns the status of the process L.</p>
                                <p>The status can be 0 for a normal process, an error code if the process ends execution with an error, or LUA_YIELDif the process is suspended.</p>
                            </li>
                            <li>
                                <h4>lua_toboolean</h4>
                                <code>int lua_toboolean (lua_State *L, int index);</code>
                                <p>Converts the Lua value at the acceptable index position to a C boolean (0 or 1). Like all tests in Lua, lua_tobooleanit returns 1 for each Lua value other than false and nil ; otherwise it returns 0. It also returns 0 when called without a valid index. (If you want to accept only actual boolean values, use this lua_isbooleanto check the type of the value.)</p>
                            </li>
                            <li>
                                <h4>lua_tocfunction</h4>
                                <code>lua_CFunction lua_tocfunction (lua_State *L, int index);</code>
                                <p>Converts the value located at the acceptable index into a C function. This value must be a C function; Otherwise it returns NULL.</p>
                            </li>
                            <li>
                                <h4>lua_tointeger</h4>
                                <code>lua_Integer lua_tointeger (lua_State *L, int index);</code>
                                <p>Converts the Lua value at the acceptable index to an unsigned integer of type lua_Integer. The Lua value must be a number or a string convertible to a number (see §2.2.1 ); otherwise lua_tointegerit returns 0.</p>
                                <p>If the number is not an integer, it is truncated in an unspecified way.</p>
                            </li>
                            <li>
                                <h4>lua_tolstring</h4>
                                <code>const char *lua_tolstring (lua_State *L, int index, size_t *len);</code>
                                <p>Converts the Lua value at the acceptable index position to a string ( const char*). If lenit is not NULL, it also sets *lenits length. The Lua value can be a string or a number; Otherwise the function returns NULL. If the value is a number then it lua_tolstringalso changes the current value on the stack to a string . (This change is confusing lua_nextwhen lua_tolstringapplied to keys during a table traversal.)</p>
                                <p>lua_tolstringreturns a fully aligned pointer to a string within a Lua state. This string always has a zero (' \0') after its last character (as in C), but may contain other zeros in its body. Because Lua has memory release, there are no guarantees that the pointer returned by lua_tolstringwill remain valid after the corresponding value is removed from the stack.</p>
                            </li>
                            <li>
                                <h4>lua_tonumber</h4>
                                <code>lua_Number lua_tonumber (lua_State *L, int index);</code>
                                <p>Converts the Lua value given at the acceptable index position to a number (see lua_Number). The Lua value must be a number or a string convertible to a number (see §2.2.1 ); Otherwise lua_tonumberit returns 0.</p>
                            </li>
                            <li>
                                <h4>lua_topointer</h4>
                                <code>const void *lua_topointer (lua_State *L, int index);</code>
                                <p>Converts the value at the acceptable index to a generic C pointer ( void*). The value can be a userdata , a table, a process, or a function; Otherwise lua_topointerit returns NULL. Lua makes sure that different objects return different pointers. There is no direct way to convert a pointer back to its original value.</p>
                                <p>Typically this function is only used for debugging information.</p>
                            </li>
                            <li>
                                <h4>lua_tostring</h4>
                                <code>const char *lua_tostring (lua_State *L, int index);</code>
                                <p>Equivalent to lua_tolstringwith lenequal to NULL.</p>
                            </li>
                            <li>
                                <h4>lua_tothread</h4>
                                <code>lua_State *lua_tothread (lua_State *L, int index);</code>
                                <p>Converts the value to the acceptable index position in a Lua process (represented as lua_State*). This value must be a process; Otherwise the function returns NULL.</p>
                            </li>
                            <li>
                                <h4>lua_touserdata</h4>
                                <code>void *lua_touserdata (lua_State *L, int index);</code>
                                <p>If the value at the acceptable index position is a complete userdata , it returns the address of its memory block. If the value is a lightweight userdata , it returns its pointer. In other case it returns NULL.</p>
                            </li>
                            <li>
                                <h4>lua_type</h4>
                                <code>int lua_type (lua_State *L, int index);</code>
                                <p>Returns the type of the value at the acceptable index or LUA_TNONEif the address is invalid (that is, an index to an "empty" position on the stack). The types returned by lua_typeare encoded by the following constants, defined in lua.h: LUA_TNIL, LUA_TNUMBER, LUA_TBOOLEAN, LUA_TSTRING, LUA_TTABLE, LUA_TFUNCTION, LUA_TUSERDATA, LUA_TTHREADand LUA_TLIGHTUSERDATA.</p>
                            </li>
                            <li>
                                <h4>lua_typename</h4>
                                <code>const char *lua_typename (lua_State *L, int tp);</code>
                                <p>Returns the name of the type encoded by the value tp, which must be one of the returned values lua_type.</p>
                            </li>       
                            <li>
                                <h4>lua_Writer</h4>
                                <code>typedef int (*lua_Writer) (lua_State *L,</code><br>
                                <code>const void* p,</code><br>
                                <code>size_t sz,</code><br>
                                <code>void* ud);</code>
                                <p>The writer function used by lua_dump. Each time it produces another chunk , lua_dumpit calls the writer, passing it the buffer to be written to ( p), its size ( sz), and the argument datagiven to lua_dump.</p>
                                <p>The writer returns an error code: 0 means no errors and any other value means an error and prevents lua_dumpcalling the writer again.</p>
                            </li>           
                            <li>
                                <h4>lua_xmove</h4>
                                <code>void lua_xmove (lua_State *from, lua_State *to, int n);</code>
                                <p>Exchanges values between different processes of the same global state.</p>
                                <p>This function removes nvalues from the stack indicated by fromand places them on the stack indicated by to.</p>
                            </li>
                            <li>
                                <h4>lua_yield</h4>
                                <code>int lua_yield (lua_State *L, int nresults);</code>
                                <p>Produces the transfer of a coroutine.</p>
                                <p>This function should only be called as a return expression from a C function, as follows:</p>
                                <code>return lua_yield (L, nresults);</code>
                                <p>When a C function calls lua_yieldthis way, the coroutine that is running suspends its execution, and the call that lua_resumestarted this coroutine returns. The argument nresultsis the number of values on the stack that are passed as results to lua_resume.</p>
                            </li>
                        </ul>
                        <li>
                            <h3>The debugging interface</h3>
                            <p>Lua has no internal debugging utilities. Instead it offers a special interface through functions and hooks . This interface allows the construction of different types of debuggers, code analyzers and other tools that need "internal information" from the interpreter.</p>
                            <ul>
                                <li>
                                    <h4>lua_Debug</h4>
                                    <code>typedef struct lua_Debug {</code><br>
                                    <code>int event;</code><br>
                                    <code>const char *name; /* (n) */</code><br>
                                    <code>const char *namewhat; /* (n) */</code><br>
                                    <code>const char *what; /* (S) */</code><br>
                                    <code>const char *source; /* (S) */</code><br>
                                    <code>int currentline; /* (l) */</code><br>
                                    <code>int nups; /* (u) number of upvalues */</code><br>
                                    <code>int linedefined; /* (S) */</code><br>
                                    <code>int lastlinedefined; /* (S) */</code><br>
                                    <code>char short_src[LUA_IDSIZE]; /* (S) */</code><br>
                                    <code>/* private part */</code><br>
                                    <code>other fields </code><br>
                                    <code>} lua_Debug;</code><br>
                                    <p>A structure used to hold different pieces of information about the active function. lua_getstackfills only the private part of this structure, for later use. To fill out other fields lua_debugwith useful information, call lua_getinfo.</p>
                                    <p>The fields lua_debughave the following meaning:</p>
                                    <ul>
                                        <li>
                                            <h5>source:</h5>
                                            <p>If the function was defined on a string then sourceit is that string . If the function was defined in a file then sourceit starts with a ' @' character followed by the file name.</p>
                                        </li>
                                        <li>
                                            <h5>short_src: </h5>
                                            <p>a "printable" version of source, which will be used in error messages.</p>
                                        </li>
                                        <li>
                                            <h5>linedefined- </h5>
                                            <p>The line number where the function definition begins.</p>
                                        </li>
                                        <li>
                                            <h5>lastlinedefined:</h5>
                                            <p>the line number where the function definition ends.</p>
                                        </li>
                                        <li>
                                            <h5>what:</h5>
                                            <p>the string "Lua" if the function is a Lua function, "C"if the function is a C function, "main"if it is the main part of a chunk , and "tail"if it is a function that makes a tail call. It is the latter case Lua does not have more information about the function.</p>
                                        </li>
                                        <li>
                                            <h5>currentline-</h5>
                                            <p>The current line where the given function is being executed. When this information is not available, currentlineit takes the value -1 .</p>
                                        </li>
                                        <li>
                                            <h5>name:</h5>
                                            <p>a reasonable name for the given function. Because functions in Lua are first-class values, they do not have a fixed name: some functions can be the value of global variables, while others can be stored only in a field of a table. The function lua_getinfoanalyzes how the function was invoked to find a suitable name for it. If you can't find it then nombreit is done NULL.</p>
                                        </li>
                                        <li>
                                            <h5>namewhat:</h5>
                                            <p>explains the field nombre. The value of namewhatcan be "global", "local", "method", "field", "upvalue"or ""(an empty string ), depending on how the function was invoked. (Lua uses an empty string when other options are not suitable.)</p>
                                        </li>
                                        <li>
                                            <h5>nups:</h5>
                                            <p>the number of upvalues of the function.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h4>lua_gethook</h4>
                                    <code>lua_Hook lua_gethook (lua_State *L);</code>
                                    <p>Returns the current hook function .</p>
                                </li>
                                <li>
                                    <h4>lua_gethookcount</h4>
                                    <code>int lua_gethookcount (lua_State *L);</code>
                                    <p>Returns the current hook counter .</p>
                                </li>
                                <li>
                                    <h4>lua_gethookmask</h4>
                                    <code>int lua_gethookmask (lua_State *L);</code>
                                    <p>Returns the mask of the current hook .</p>
                                </li>
                                <li>
                                    <h4>lua_getinfo</h4>
                                    <code>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</code>
                                    <p>Returns information about a specific function or function invocation.</p>
                                    <p>To obtain information about a function invocation, the parameter armust be a valid activation record, which has been filled with a previous call to lua_getstackor given as an argument to a hook (see lua_Hook).</p>
                                    <p>To obtain information about a function, place it on the top of the stack and start the string what with the character ' >'. (In that case, lua_getinforemove the function from the top of the stack.) For example, to find out on which line a function was defined fyou can use the following code:</p>
                                    <code>lua_Debug ar;</code><br>
                                    <code>lua_getfield(L, LUA_GLOBALSINDEX, "f"); /* get the global 'f' */</code><br>
                                    <code>lua_getinfo(L, ">S", &ar);</code><br>
                                    <code>printf("%d\n", ar.linedefined);</code>
                                    <p>Each character in the string what selects the fields of the structure arthat will be filled or a value that will be placed on top of the stack:</p>
                                    <ul>
                                        <li>
                                            <h5>' n':</h5>
                                            <p>fill in the fields nameand namewhat;</p>
                                        </li>
                                        <li>
                                            <h5>' S':</h5>
                                            <p>fill in the fields source, short_src, linedefined, lastlinedefinedand what;</p>
                                        </li>
                                        <li>
                                            <h5>' l':</h5>
                                            <p>fill in the field currentline;</p>
                                        </li>
                                        <li>
                                            <h5>' u': </h5>
                                            <p>fill in the field nups;</p>
                                        </li>
                                        <li>
                                            <h5>' f':</h5>
                                            <p>Places the function that is executing at the given level onto the stack;
                                            </p>
                                        </li>
                                        <li>
                                            <h5>' L':</h5>
                                            <p>Places on the stack a table whose indexes are the numbers of the lines that are valid in the function. (A valid line is a line with some code associated with it, that is, a line where a breakpoint can be placed. Invalid lines include empty lines and comments.</p>
                                        </li>
                                    </ul>
                                    <p>This function returns 0 on an error (for example, an invalid option in what).</p>
                                </li>
                                <li>
                                    <h4>lua_getlocal</h4>
                                    <code>const char *lua_getlocal (lua_State *L, lua_Debug *ar, int n);</code>
                                    <p>Gets information about a local variable of a given activation record. The argument armust be a valid activation record that was populated in a previous call or lua_getstackgiven as an argument to a hook (see lua_Hook). The index nselects which local variable to inspect (1 is the first argument or the first active local variable, and so on, until the last active local variable). lua_getlocalplaces the value of the variable on the stack and returns its name.</p>
                                    <p>Variable names starting with ' &#40;' (open parentheses) represent internal variables (loop control variables, temporary variables, and local variables of C functions).</p>
                                    <p>Returns NULL(and pushes nothing on the stack) when the index is greater than the number of active local variables.</p>
                                </li>
                                <li>
                                    <h4>lua_getstack</h4>
                                    <code>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</code>
                                    <p>Gets information about the interpreter's running stack.</p>
                                    <p>This function fills parts of a structure lua_debugwith an identification of the activation record of the function that is running at the given level. Level 0 is the function currently running, while level n+1 is the function that invoked the function at level n . When there are no errors, lua_getstackreturn 1; when called with a level greater than the stack size it returns 0.</p>
                                </li>
                                <li>
                                    <h4>lua_getupvalue</h4>
                                    <code>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</code>
                                    <p>Gets information about an upavalue of an instance. (For Lua functions, upvalues are local variables that are external to the function that uses them, and are therefore included in its instance.) lua_getupvalueGets the index nof an upvalue , places its value on the stack, and returns its name. funcindexpoints to the instance on the stack. (The upvalues ​​do not follow any particular order, since they are active throughout the entire function. Therefore, they are numbered in an arbitrary order.)</p>
                                    <p>Returns NULL(and puts nothing on the stack) when the index is greater than the number of upvalues. For C functions this function uses the empty string"" as the name for all upvalues .</p>
                                </li>
                                <li>
                                    <h4>lua_Hook</h4>
                                    <code>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</code>
                                    <p>Type for debugging hook functions.</p>
                                    <p>Every time a hook is invoked, its argument arhas in its field eventthe event that activated the hook . Lua identifies these events with the following constants: LUA_HOOKCALL, LUA_HOOKRET, LUA_HOOKTAILRET, LUA_HOOKLINEand LUA_HOOKCOUNT. Additionally, for line events, the field is also set currentline. To get the value of some other field in ar, the hook must call lua_getinfo. For return events, eventit can be LUA_HOOKRET, the normal value, or LUA_HOOKTAILRET. In the latter case, Lua is simulating a return from a function that has made a tail call; in this case, it is useless to call lua_getinfo.</p>
                                    <p>While Lua is executing a hook , it disables other hook calls . Therefore, if a hook calls Lua again to execute a function or a chunk then that execution occurs without any call to hooks .</p>
                                </li>
                                <li>
                                    <h4>lua_sethook</h4>
                                    <code>int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</code>
                                    <p>Sets the debugging hook function.</p>
                                    <p>funcis the hook function . specifies in which events the hookmask should be called : it is formed by the "or" operation applied to the bits of the constants , , , and . The argument only makes sense when the mask includes . For each event, the hook is invoked as explained below:LUA_MASKCALLLUA_MASKRETLUA_MASKLINELUA_MASKCOUNTcountLUA_MASKCOUNT</p>
                                    <ul>
                                        <li>
                                            <p>The call hook is invoked when the interpreter calls a function. The hook is called right after Lua enters the new function, before the function takes its arguments.</p>
                                        </li>
                                        <li>
                                            <p>The "return" hook is invoked when the interpreter returns from a function. The hook is invoked just before Lua leaves the function. You do not have access to the values returned by the function.</p>
                                        </li>
                                        <li>
                                            <p>The "line" hook is invoked when the interpreter is about to begin executing a new line of code, or when it jumps back in the code (even on the same line). (This event only occurs when Lua is executing a Lua function.)</p>
                                        </li>
                                        <li>
                                            <p>The "count" hook is invoked after the interpreter executes a number of instructions equal to count. (This event only occurs when Lua is executing a Lua function.)</p>
                                        </li>
                                    </ul>
                                    <p>A hook is disabled by setting maskit to zero.</p>
                                </li>
                                <li>
                                    <h4>lua_setlocal</h4>
                                    <code>const char *lua_setlocal (lua_State *L, lua_Debug *ar, int n);</code>
                                    <p>Sets the value of a local variable of a given activation record. The arguments arand nare like those of lua_getlocal. lua_setlocalassigns the value at the top of the stack to the variable and returns its name. It also removes its value from the stack.</p>
                                    <p>Returns NULL(and does nothing on the stack) when the index is greater than the number of active local variables.</p>
                                </li>
                                <li>
                                    <h4>lua_setupvalue</h4>
                                    <code>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</code>
                                    <p>Sets the value of an upvalue of an instance. The arguments funcindexand nare like those of lua_getupvalue. Assigns the value at the top of the stack to the upvalue and returns its name. It also removes the value from the stack.</p>
                                    <p>Returns NULL(and does nothing with the stack) when the index is greater than the number of upavalues.</p>
                                </li>
                            </ul>
                        </li>
                    </li>
                </ol>
            </section>
            <section class="main-section" id="auxiliary-library">
                <header>The auxiliary library</header>
                <p>The auxiliary library provides several convenient functions for interfacing C with Lua. While the base API provides the primitive functions for all interactions between C and Lua, the auxiliary library provides high-level functions for some common tasks.</p>
                <p>All auxiliary library functions are defined in the header file lauxlib.hand are prefixed with luaL_.</p>
                <p>They are all built on top of the basic API so they don't really provide anything new that can't be done with the API.</p>
                <p>Some functions in the auxiliary library are used to check arguments of C functions. Their names are always luaL_check*or luaL_opt*. All of these functions raise an error if the verification is not satisfied. Because the error message is formatted for arguments (for example, "bad argument #1"), these functions should not be used for other values on the stack.</p>
                <ol>
                    <h3> Functions and types</h3>
                    <p>Here we have the list of all functions and types of the auxiliary library in alphabetical order.</p>
                    <ul>
                        <li>
                            <h4>luaL_addchar</h4>
                            <code>void luaL_addchar (luaL_Buffer *B, char c);</code>
                            <p>Adds the character cto the buffer B (see luaL_Buffer).</p>
                        </li>
                        <li>
                            <h4>luaL_addlstring</h4>
                            <code>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</code>
                            <p>Adds the string it points to swith length lto the buffer B (see luaL_Buffer). The string can contain zeros.</p>
                        </li>
                        <li>
                            <h4>luaL_addsize</h4>
                            <code>void luaL_addsize (luaL_Buffer *B, size_t n);</code>
                            <p>Adds a length stringn previously copied into the buffer area (see luaL_prepbuffer) to the buffer B (see luaL_Buffer).</p>
                        </li>
                        <li>
                            <h4>luaL_addstring</h4>
                            <code>void luaL_addstring (luaL_Buffer *B, const char *s);</code>
                            <p>Adds a zero-terminated string to the one pointing sto the buffer B (see luaL_Buffer). The string cannot contain zeros.</p>
                        </li>
                        <li>
                            <h4>luaL_addvalue</h4>
                            <code>luaL_addvalue (luaL_Buffer *B);</code>
                            <p>Adds the value at the top of the stack to the buffer B (see luaL_Buffer), removing it from the stack.</p>
                            <p>This is the only function associated with string buffers that can ( and should) be called with an extra element on the stack, which is the value that should be added to the buffer .</p>
                        </li>
                        <li>
                            <h4>luaL_argcheck</h4>
                            <code>void luaL_argcheck (lua_State *L,</code><br>
                            <code>int cond,</code><br>
                            <code>int narg,</code><br>
                            <code>const char *extramsg);</code>
                            <p>Check if condit is true. If not, it triggers an error with the message</p>
                            <code>"bad argument #&lt;numarg&gt; to &lt;func&gt; (&lt;extramsg&gt;)"</code>
                            <p>where funcit is retrieved from the call stack.</p>
                        </li>
                        <li>
                            <h4>luaL_argerror</h4>
                            <code>int luaL_argerror (lua_State *L, int narg, const char *extramsg);</code>
                            <p>Trigger an error with the message</p>
                            <code>"bad argument #&lt;numarg&gt; to &lt;func&gt; (&lt;extramsg&gt;)"</code>
                            <p>where funcit is retrieved from the call stack.</p>
                            <p>This function never returns, but it is common to use it in C functions of the form return luaL_argerror(args).</p>
                        </li>
                        <li>
                            <h4>luaL_Buffer</h4>
                            <code>typedef struct luaL_Buffer luaL_Buffer;</code>
                            <p>Type for a string buffer .</p>
                            <p>A string buffer allows C code to piecemeal build Lua strings . Its methodology of use is as follows:</p>
                            <ul>
                                <li>
                                    <p>bFirst a variable of type is declared luaL_Buffer.</p>
                                </li>
                                <li>
                                    <p>Then it is initialized with a call to luaL_buffinit(L, &b).</p>
                                </li>
                                <li>
                                    <p>Then the pieces of the string are added to the buffer , invoking one of the functions luaL_add*.</p>
                                </li>
                                <li>
                                    <p>It is terminated by calling luaL_pushresult(&b). This call leaves the final string at the top of the stack.</p>
                                </li>
                            </ul>
                            <p>During normal operation, a string buffer uses a variable number of positions on the stack. Thus, while you are using the buffer , you cannot assume that you know the position of the top of the stack. The stack may be used between successive calls to buffer operations as long as its usage is balanced ; that is, when a buffer operation is invoked , the stack is at the same level as it was immediately before the previous buffer operation . (The only exception to this rule is luaL_addvalue.) After calling the luaL_pushresultstack it is back at the same level it was when the buffer was initialized, plus the final string on top.</p>
                        </li>
                        <li>
                            <h4>luaL_buffinit</h4>
                            <code>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</code>
                            <p>Initializes a buffer B . This function does not reserve any new memory space; the buffer must be declared as a variable (see luaL_Buffer).</p>
                        </li>
                        <li>
                            <h4>luaL_callmeta</h4>
                            <code>int luaL_callmeta (lua_State *L, int obj, const char *e);</code>
                            <p>Invokes a metamethod.</p>
                            <p>If the object with index objhas a metatable and it has a field e, this function calls this field and passes the object as the only argument. In this case the function returns 1 and places the value returned by the call on the stack. If there is no metatable or no metamethod the function returns 0 (without placing any value on the stack).</p>
                        </li>
                        <li>
                            <h4>luaL_checkany</h4>
                            <code>void luaL_checkany (lua_State *L, int narg);</code>
                            <p>Checks if the function has an argument of any type (including nil ) at position narg.</p>
                        </li>
                        <li>
                            <h4>luaL_checkint</h4>
                            <code>int luaL_checkint (lua_State *L, int narg);</code>
                            <p>Checks if the nargfunction argument is a number and returns this number as int(by performing a cast in C).</p>
                        </li>
                        <li>
                            <h4>luaL_checkinteger</h4>
                            <code>lua_Integer luaL_checkinteger (lua_State *L, int narg);</code>
                            <p>nargChecks if the function argument is a number and returns it as type lua_Integer.</p>
                        </li>
                        <li>
                            <h4>luaL_checklong</h4>
                            <code>long luaL_checklong (lua_State *L, int narg);</code>
                            <p>nargChecks if the function argument is a number and returns it as long(performing a cast in C).</p>
                        </li>
                        <li>
                            <h4>luaL_checklstring</h4>
                            <code>const char *luaL_checklstring (lua_State *L, int narg, size_t *l);</code>
                            <p>nargChecks if the function argument is a string and returns the same; If lnot, NULLplace the length of the string in *l.</p>
                            <p>This function uses lua_tolstringto get its result, so all conversions and precautions associated with that function apply here.</p>
                        </li>
                        <li>
                            <h4>luaL_checknumber</h4>
                            <code>lua_Number luaL_checknumber (lua_State *L, int narg);</code>
                            <p>nargChecks if the function argument is a number and returns the same.</p>
                        </li>
                        <li>
                            <h4>luaL_checkoption</h4>
                            <code>int luaL_checkoption (lua_State *L,</code><br>
                            <code>int narg,</code><br>
                            <code>const char *def,</code><br>
                            <code>const char *const lst[]);</code>
                            <p>nargChecks if the function argument is a string and looks for it in the array lst (which must be NULL terminated). Returns the index in the array where the string was found . Triggers an error if the argument is not a string or if the string could not be found .</p>
                            <p>If defnot NULL, it is used defas the default value when the function has no argument nargor if this argument is nil .</p>
                            <p>This is a useful function for mapping strings to C enums. The normal convention in Lua libraries is to use strings instead of numbers to select options.</p>
                        </li>
                        <li>
                            <h4>luaL_checkstack</h4>
                            <code>void luaL_checkstack (lua_State *L, int sz, const char *msg);</code>
                            <p>Increases the size of the stack by top + szelements, triggering an error if the stack cannot grow to that size. msgIt is additional text that would go in the error message.</p>
                        </li>
                        <li>
                            <h4>luaL_checkstring</h4>
                            <code>const char *luaL_checkstring (lua_State *L, int narg);</code>
                            <p>Checks if the nargfunction argument is a string and returns it.</p>
                            <p>This function uses lua_tolstringto get its result, so all conversions and precautions associated with that function apply here.</p>
                        </li>
                        <li>
                            <h4>luaL_checktype</h4>
                            <code>void luaL_checktype (lua_State *L, int narg, int t);</code>
                            <p>Checks if the nargfunction argument has type t.</p>
                        </li>
                        <li>
                            <h4>luaL_checkudata</h4>
                            <code>void *luaL_checkudata (lua_State *L, int narg, const char *tname);</code>
                            <p>Checks if the nargfunction argument is a userdata of type tname(see luaL_newmetatable).</p>
                        </li>
                        <li>
                            <h4>luaL_dofile</h4>
                            <code>int luaL_dofile (lua_State *L, const char *filename);</code>
                            <p>Load and execute the given file. It is defined in a macro:</p>
                            <code>(luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))</code>
                            <p>Returns 0 if there are no errors or 1 in case of an error.</p>
                        </li>
                        <li>
                            <h4>luaL_dostring</h4>
                            <code>int luaL_dostring (lua_State *L, const char *str);</code>
                            <p>Load and execute the given string . It is defined in a macro:</p>
                            <code>(luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))</code>
                            <p>Returns 0 if there are no errors or 1 in case of an error.</p>
                        </li>
                        <li>
                            <h4>luaL_error</h4>
                            <code>int luaL_error (lua_State *L, const char *fmt, ...);</code>
                            <p>Triggers an error. The format of the message is given by fmtany extra arguments, following the same rules as lua_pushfstring. It also adds the name of the file and the line number where the error occurred to the beginning of the message, if this information is available.</p>
                            <p>This function never returns, but it is common to use it in the form return luaL_error(args)of C functions.</p>                           
                        </li>
                        <li>
                            <h4>luaL_getmetafield</h4>
                            <code>int luaL_getmetafield (lua_State *L, int obj, const char *e);</code>
                            <p>ePlaces the object's metatable field at the index position on top of the stack obj. If the object does not have a metatable or if the object does not have this field, it returns 0 and leaves the stack intact.</p>                         
                        </li>
                        <li>
                            <h4>luaL_getmetatable</h4>
                            <code>void luaL_getmetatable (lua_State *L, const char *tname);</code>
                            <p>Places the metatable associated with the name in the record on top of the stack tname(see luaL_newmetatable).</p>                            
                        </li>
                        <li>
                            <h4>luaL_gsub</h4>
                            <code>const char *luaL_gsub (lua_State *L,</code><br>
                            <code>const char *s,</code><br>
                            <code>const char *p,</code><br>
                            <code>const char *r);</code>
                            <p>Creates a copy of the string s by replacing any occurrence of the string p with the string r . Places the resulting string on top of the stack and returns its value.</p>                            
                        </li>
                        <li>
                            <h4>luaL_loadbuffer</h4>
                            <code>int luaL_loadbuffer (lua_State *L,</code><br>
                            <code>const char *buff,</code><br>
                            <code>size_t sz,</code><br>
                            <code>const char *name);</code>
                            <p>Load a buffer as a Lua chunk . This function is used lua_loadto load the chunk into the buffer pointed to by buffwith size sz.</p>                           
                            <p>This function returns the same result as lua_load. nameis the name of the chunk , used for debugging information and in error messages.</p>
                        </li>
                        <li>
                            <h4>luaL_loadfile</h4>
                            <code>int luaL_loadfile (lua_State *L, const char *filename);</code>
                            <p>Load a file as a Lua chunk . This function is used lua_loadto load the chunk that is in the file filename. If filenameit is NULLthen it is loaded from standard input. The first line in the file is ignored if it begins with #.</p>
                            <p>This function returns the same result as lua_load, but has an extra error code LUA_ERRFILEif it cannot read or open the file.</p>
                            <p>Since lua_loadthis function only loads the chunk and does not execute it.</p>
                        </li>
                        <li>
                            <h4>luaL_loadstring</h4>
                            <code>int luaL_loadstring (lua_State *L, const char *s);</code>
                            <p>Load a string as a Lua chunk . This function is used lua_loadto load the chunk that is in the string s ending in a zero character.</p>
                            <p>This function returns the same result as lua_load.</p>
                            <p>Since lua_loadthis function only loads the chunk and does not execute it.</p>
                        </li>
                        <li>
                            <h4>luaL_newmetatable</h4>
                            <code>int luaL_newmetatable (lua_State *L, const char *tname);</code>
                            <p>If the record already has a key, tnameit returns 0. Otherwise, it creates a new table that will be used as the userdata metatable , adding the key tnameto the record, and returning 1.</p>
                            <p>In both cases it places the final value associated with in the register on top of the stack tname.</p>
                        </li>
                        <li>
                            <h4>luaL_newstate</h4>
                            <code>lua_State *luaL_newstate (void);</code>
                            <p>Creates a new Lua state, invoking it lua_newstatewith a memory reserve function based on the standard C function reallocand setting a "panic" function (see lua_atpanic) that prints a message to standard error output in case of a fatal error.</p>
                            <p>Returns the new state or NULLif a memory reservation error occurred.</p>
                        </li>
                        <li>
                            <h4>luaL_openlibs</h4>
                            <code>void luaL_openlibs (lua_State *L);</code>
                            <p>Opens all Lua standard libraries in the given state.</p>
                        </li>
                        <li>
                            <h4>luaL_optint</h4>
                            <code>int luaL_optint (lua_State *L, int narg, int d);</code>
                            <p>If the nargfunction argument is a number, it returns this as a int. If this argument is absent or nil returns d. Otherwise it triggers an error.</p>
                        </li>
                        <li>
                            <h4>luaL_optinteger</h4>
                            <code>lua_Integer luaL_optinteger (lua_State *L,</code><br>
                            <code>int narg,</code><br>
                            <code>lua_Integer d);</code>
                            <p>nargIf the function argument is a number, it returns the same as lua_Integer. If this argument is absent or nil returns d. Otherwise it triggers an error.</p>
                        </li>
                        <li>
                            <h4>luaL_optlong</h4>
                            <code>long luaL_optlong (lua_State *L, int narg, long d);</code>
                            <p>nargIf the function argument is a number, it returns the same as long. If this argument is absent or nil returns d. Otherwise it triggers an error.</p>                          
                        </li>
                        <li>
                            <h4>luaL_optlstring</h4>
                            <code>const char *luaL_optlstring (lua_State *L,</code><br>
                            <code>int narg,</code><br>
                            <code>const char *d,</code><br>
                            <code>size_t *l);</code>
                            <p>If the nargfunction argument is a string, it returns this one. If this argument is absent or nil returns d. Otherwise it triggers an error.</p>
                            <p>If lnot, NULLplace the length of the result in *l.</p>
                        </li>
                        <li>
                            <h4>luaL_optnumber</h4>
                            <code>lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);</code>
                            <p>If the nargfunction argument is a number, it returns the same number. If this argument is absent or nil returns d. Otherwise it triggers an error.</p>                           
                        </li>
                        <li>
                            <h4>luaL_optstring</h4>
                            <code>const char *luaL_optstring (lua_State *L,</code><br>
                            <code>int narg,</code><br>
                            <code>const char *d);</code>
                            <p>If the nargfunction argument is a string, it returns this one. If this argument is absent or nil returns d. Otherwise it triggers an error.</p>
                        </li>
                        <li>
                            <h4>luaL_prepbuffer</h4>
                            <code>char *luaL_prepbuffer (luaL_Buffer *B);</code>
                            <p>Returns an address that points to a size space where a stringLUAL_BUFFERSIZE can be copied to be added to the buffer (see ). After copying the string into this space it must be called with the size of the string to actually add it to the buffer . BluaL_BufferluaL_addsize</p>
                        </li>
                        <li>
                            <h4>luaL_pushresult</h4>
                            <code>void luaL_pushresult (luaL_Buffer *B);</code>
                            <p>Ends use of the buffer B , leaving the string at the top of the stack.</p>
                        </li>
                        <li>
                            <h4>luaL_ref</h4>
                            <code>int luaL_ref (lua_State *L, int t);</code>
                            <p>Creates and returns a table reference at the index position tfor the object at the top of the stack (and removes it from the stack).</p>
                            <p>A reference is a unique integer key. As long as you do not manually add integer keys to the table t, luaL_refit ensures the uniqueness of the returned key. An object pointed to by the reference can be retrieved rby invoking lua_rawgeti(L, t, r). The function luaL_unrefdeletes a reference and its associated object.</p>
                            <p>If the object at the top of the stack is nil , luaL_refreturn the constant LUA_REFNIL. The constant is guaranteed LUA_NOREFto be different from any reference returned by luaL_ref.</p>
                        </li>
                        <li>
                            <h4>luaL_Reg</h4>
                            <code>typedef struct luaL_Reg {</code><br>
                            <code>const char *name;</code><br>
                            <code>lua_CFunction func;</code><br>
                            <code>} luaL_Reg;</code><br>
                            <p>Type for arrays of functions to be registered by luaL_register. nameis the name of the function and funcis a pointer to it. Any array of luaL_Regmust end with a "sentinel" entry in which nameboth funcare NULL.</p>                            
                        </li>
                        <li>
                            <h4>luaL_register</h4>
                            <code>void luaL_register (lua_State *L,</code><br>
                            <code>const char *libname,</code><br>
                            <code>const luaL_Reg *l);</code><br>
                            <code>Open a library.</code>
                            <p>When called with libnameequals to it NULLsimply registers all the functions in the list l(see luaL_Reg) in the table at the top of the stack.</p>
                            <p>When called with a libnamenon-null value, it creates a new table t, sets it as the value of the global variable libname, sets it as the value of package.loaded[libname], and registers all the functions in the list in it l. If a table exists in package.loaded[libname]or in the variable, libnamereuse this table instead of creating a new one.</p>
                            <p>In either case the function leaves the table at the top of the stack.</p>
                        </li>
                        <li>
                            <h4>luaL_typename</h4>
                            <code>const char *luaL_typename (lua_State *L, int index);</code>
                            <p>Returns the type name of the value located at the given index.</p>
                        </li>
                        <li>
                            <h4>luaL_typerror</h4>
                            <code>int luaL_typerror (lua_State *L, int narg, const char *tname);</code>
                            <p>Generates an error with a message of the form:</p>
                            <code>location : bad argument narg to function ( tname expected, got rt )</code>
                            <p>where location is produced by luaL_where, function is the name of the current function, and rt is the type name of the current argument.</p>
                        </li>
                        <li>
                            <h4>luaL_unref</h4>
                            <code>void luaL_unref (lua_State *L, int t, int ref);</code>
                            <p>Frees the reftable reference in the index t(see luaL_ref). The entry is removed from the table, so the memory reserved for the object referred to in it can be freed. The reference refis also freed to be reused.</p>
                            <p>If refit is LUA_NOREFor LUA_REFNIL, luaL_unrefit does nothing.</p>
                        </li>
                        <li>
                            <h4>luaL_where</h4>
                            <code>void luaL_where (lua_State *L, int lvl);</code>
                            <p>Places a string on the top of the stack identifying the control's current position in the lvlcall stack level. Typically this string has the format:</p>
                            <code>chunkname : currentline :</code>
                            <p>Level 0 is the function currently running, level 1 is the function that called the current function, etc.</p>
                            <p>This function is used to construct a prefix for error messages.</p>
                        </li>
                    </ul>
                </ol>
            </section>
            <section class="main-section" id="standard-libraries">
                <header>Standard Libraries</header>
                <p>The Lua standard libraries provide useful functions that are implemented directly through the C API. Some of these functions provide essential services to the language (for example, typeand getmetatable); others provide access to "external" services (for example, I/O); and others could be implemented in Lua itself but are very useful or have critical runtime requirements and deserve a C implementation (e.g., sort).</p>
                <p>All libraries are implemented through the official C API and are provided as separate modules in C. Lua currently has the following standard libraries:</p>
                <ul>
                    <li>
                        <p>basic library;</p>
                    </li>
                    <li>
                        <p>packaging library;</p>
                    </li>
                    <li>
                        <p>string handling ;</p>
                    </li>
                    <li>
                        <p>table management;</p>
                    </li>
                    <li>
                        <p>mathematical functions (sin, log, etc.);</p>
                    </li>
                    <li>
                        <p>input and output (I/O);</p>
                    </li>
                    <li>
                        <p>interaction with the operating system;</p>
                    </li>
                    <li>
                        <p>debugging utilities.</p>
                    </li>
                </ul>
                <p>Except for the basic and packaging libraries, each library provides all of its functions as fields of global tables or as methods of its objects.</p>
                <p>To access these libraries the host C program must call luaL_openlibs, which opens all the standard libraries. Alternatively they can be opened individually by calling luaopen_base(the basic library), luaopen_package(the packaging library), (the stringluaopen_string library ), (the table library), (the math library), (the input/output library) , (the Operating System library) and (the debugging library). These functions are declared in and should not be called directly: they should be called like any other Lua C function, for example, using .luaopen_tableluaopen_mathluaopen_ioluaopen_osluaopen_debuglualib.hlua_call</p>
                <ol>
                    <li>
                        <h3>Basic functions</h3>
                        <p>The core library provides some core Lua functions. If you do not want to include this library in an application, you should carefully analyze whether you need to provide implementations of some of its utilities.</p>
                        <ul>
                            <li>
                                <h4>assert (v [, mensaje])</h4>
                                <p>Triggers an error when the value of its argument vis false (for example, nil or false ); otherwise it returns all its arguments. mensajeIt is an error message; when absent it is used by default "assertion failed!".</p>
                            </li>
                            <li>
                                <h4>collectgarbage (opt [, arg])</h4>
                                <p>This function is a generic interface to the memory releaser. It performs various functions according to its first argument opt:</p>
                                <ul>
                                    <li>
                                        <h5>"stop": </h5>
                                        <p>stops the memory release.</p>
                                    </li>
                                    <li>
                                        <h5>"restart": </h5>
                                        <p>restart the memory cleaner.</p>
                                    </li>
                                    <li>
                                        <h5>"collect":</h5>
                                        <p>Performs a complete memory release cycle.</p>
                                    </li>
                                    <li>
                                        <h5>"count": </h5>
                                        <p>Returns the total memory in use by Lua (in Kbytes).</p>
                                    </li>
                                    <li>
                                        <h5>"step": </h5>
                                        <p>Performs a memory release step. The "size" of the step is controlled by arg(larger values ​​mean more steps) in an unspecified way. If you want to control the step size, you must experimentally tune the value of arg. Returns true if the step finishes a release cycle.</p>
                                    </li>
                                    <li>
                                        <h5>"steppause": </h5>
                                        <p>sets arg/100 as the new value for the releaser pause.</p>
                                    </li>
                                    <li>
                                        <h5>"setstepmul": </h5>
                                        <p>sets arg/100 as the new value for the release step multiplier.</p>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <h4>dofile (nombre_de_fichero)</h4>
                                <p>Open the file with the given name and execute its contents as a Lua chunk . When called without arguments, dofileexecutes the contents of standard input ( stdin). Returns all values ​​returned by the chunk . On error, dofileit propagates the error to its caller (that is, dofileit does not run in protected mode).</p>
                            </li>
                            <li>
                                <h4>error (mensaje [, nivel])</h4>
                                <p>Terminates the last protected function call, setting mensajethe error message. The function errornever returns.</p>
                                <p>It usually erroradds, at the beginning of the message, some information about the position of the error. The argument nivelspecifies how to get the position of the error. With level 1 (default) the error position is where the function was invoked error. Level 2 points the error to the place where the function that called error; and so on. Passing a value of 0 as a level prevents adding the position information to the message.</p>
                            </li>
                            <li>
                                <h4>_G</h4>
                                <p>A global variable (not a function) that stores the global environment (that is, _G._G = _G). Lua itself does not use this variable; changing its value does not affect any environment, nor vice versa. (Use setfenvto change environments.)</p>
                            </li>
                            <li>
                                <h4>getfenv ([f])</h4>
                                <p>Returns the environment currently in use by the function. fIt can be a Lua function or a number that specifies the function at that level of the stack: level 1 is the function that invokes getfenv. If the given function is not a Lua function or fis 0, getfenvreturns the global environment. The default value of fis 1.</p>
                            </li>
                            <li>
                                <h4>getmetatable (objeto)</h4>
                                <p>If objetoit does not have a metatable it returns nil . Otherwise, if the object's metatable has a field, "__metatable"it returns the associated value, or if not, it returns the given object's metatable.</p>
                            </li>
                            <li>
                                <h4>ipairs (t)</h4>
                                <p>Returns three values: an iterator function, the table t, and 0, such that the construction</p>
                                <code>for i,v in ipairs(t) do end</code><br>
                                <code> block</code>
                                <p>will iterate over the pairs ( 1,t[1]), ( 2,t[2]), ···, to the first integer key with a nil value in the table.</p>
                            </li>
                            <li>
                                <h4>load (func [, nombre_de_chunk])</h4>
                                <p>Load a chunk using the function functo obtain its parts. Each call to funcmust return a string that is concatenated with the previous results. A return of nil (or no value) signals the end of the chunk .</p>
                                <p>If there are no errors, it returns the compiled chunk as a function; otherwise it returns nil plus an error message. The environment of the returned function is global.</p>
                                <p>nombre_de_chunkIt is used to identify the chunk in error messages and for debugging information.</p>
                            </li>
                            <li>
                                <h4>loadfile ([nombre_de_fichero])</h4>
                                <p>Similar to load, but gets the chunk of the file nombre_de_ficheroor standard input if a name is not provided.</p>
                            </li>
                            <li>
                                <h4>loadstring (string [, nombre_de_chunk])</h4>
                                <p>Similar to load, but gets the chunk of the provided string .</p>
                                <p>To load and execute a given string use</p>
                                <code>assert(loadstring(s))()</code>
                                <p>When absent, nombre_de_chunkit defaults to the given string .</p>
                            </li>
                            <li>
                                <h4>next (tabla [, índice])</h4>
                                <p>Allows the program to go through all the fields of a table. Its first argument is a table and its second argument is an index on this table. nextreturns the next index of the table and its associated value. When invoked with nil as the second argument, nextit returns an initial index and its associated value. When called with the last index or with nil on an empty table nextit returns nil . If the second argument is absent then it is interpreted as nil . In particular it can be used next(t)to check if a table is empty.</p>
                                <p>The order in which indexes are listed is not specified, even for numeric indexes . (To traverse a table in numerical order, use the numeric for or function ipairs.)</p>
                                <p>The behavior of nextis undefined if during the traversal a value is assigned to a field that does not previously exist in the table. However, existing fields can be modified. In particular, existing fields can be deleted.</p>
                            </li>
                            <li>
                                <h4>pairs (t)</h4>
                                <p>Returns three values: the function next, the table t, and nil , so the construction</p>
                                <code>for k,v in pairs(t) do end</code><br>
                                <code>block</code>
                                <p>will iterate over all key-value pairs in the table t.</p>
                                <p>See nextfor precautions to take when modifying the table during iterations.</p>
                            </li>
                            <li>
                                <h4>pcall (f, arg1, ···)</h4>
                                <p>Invokes the function fwith the given arguments in protected mode. This means that no errors within fare propagated; instead it pcallcaptures the error and returns a status code. Its first result is the status code (boolean), which is true if the call succeeds without errors. In that case pcallit also returns all the results of the call after the first result. In case of error pcallit returns false plus an error message.</p>
                            </li>
                            <li>
                                <h4>print (···)</h4>
                                <p>Receives any number of arguments and prints their values ​​to the standard output file ( stdout), using tostringas a function to convert the arguments to strings . printIt is not designed for formatted output but only as a quick way to display values, typically for code debugging. For formatted output use string.format.</p>
                            </li>
                            <li>
                                <h4>rawequal (v1, v2)</h4>
                                <p>Checks if v1it is equal to v2, without invoking any metamethods. Returns a boolean.</p>
                            </li>
                            <li>
                                <h4>rawget (tabla, índice)</h4>
                                <p>Gets the actual value of tabla[índice]without invoking any metamethods. tablamust be a table and índiceany value other than nil .</p>
                            </li>
                            <li>
                                <h4>rawset (tabla, índice, valor)</h4>
                                <p>Assigns valorto tabla[índice]without invoking any metamethods. tablamust be a table, índiceany value other than nil , and valorany Lua value.</p>
                            </li>
                            <li>
                                <h4>select (índice, ···)</h4>
                                <p>If índiceit is a number, it returns all arguments after the number índice. Otherwise índiceit must be the string "#" , and selectreturns the total number of extra arguments it receives.</p>
                            </li>
                            <li>
                                <h4>setfenv (f, tabla)</h4>
                                <p>Sets the environment to be used by a function. fcan be a Lua function or a number that specifies the function at the stack level: level 1 is the function that invokes setfenv. setfenvreturns the given function.</p>
                                <p>As a special case, when fit is 0 setfenvthe environment of the running process changes. In this case setfenvit does not return values.</p>
                            </li>
                            <li>
                                <h4>setmetatable (tabla, metatabla)</h4>
                                <p>Sets the metatable for a given table. (You cannot change the metatable of other types from Lua, only from C.) If nilmetatabla then the metatable is removed from the given table. If the original metatable has a field an error is triggered."__metatable"</p>
                                <p>This function returns tabla.</p>
                            </li>
                            <li>
                                <h4>tonumber (e [, base])</h4>
                                <p>It tries to convert its argument into a number. If the argument is already a number or a string convertible to a number then tonumberit returns this number; otherwise it returns nil .</p>
                                <p>An optional argument specifies the basis for interpreting the number. The base can be any integer between 2 and 36, inclusive. In bases above 10 the letter ' A' (upper or lower case) represents 10, ' B' represents 11, and so on, with ' Z' representing 35. In base 10 (default), the number can have a decimal part, as well as an optional exponent (see §2.1 ). In other bases only unsigned integers are accepted.</p>
                            </li>
                            <li>
                                <h4>tostring (e)</h4>
                                <p>Receives an argument of any type and converts it to a reasonably formatted string . For complete control of how numbers are converted, use string.format.</p>
                                <p>If the metatable ehas a field "__tostring"then tostringit calls the corresponding value with eas an argument and uses the result of the call as its own result.</p>
                            </li>
                            <li>
                                <h4>type (v)</h4>
                                <p>Returns the type of its only argument, encoded as string . The possible results of this function are "nil"(a string, not the nil value ), "number", "string", "boolean, "table", "function", "thread"and "userdata".</p>
                            </li>
                            <li>
                                <h4>unpack (lista [, i [, j]])</h4>
                                <p>Returns the elements of a given table. This function is equivalent to</p>
                                <code>return list[i], list[i+1], ···, list[j]</code>
                                <p>except that this code can be written only for a fixed number of elements. By default iit is 1 and jis the length of the list, as defined via the length operator (see §2.5.5 ).</p>
                            </li>
                            <li>
                                <h4>_VERSION</h4>
                                <p>A global variable (not a function) that stores a string containing the current version of the interpreter. In this version of Lua the current content of this variable is "Lua 5.1".</p>
                            </li>
                            <li>
                                <h4>xpcall (f, err)</h4>
                                <p>This function is similar to pcall, except that an error handler can be set.</p>
                                <p>xpcallinvokes the function fin protected mode, using errthe error handler. No error within fis propagated; instead it xpcallcaptures the error, calling the function errwith the original error object, and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In that case xpcallit also returns all the results of the call after the first result. In case of error xpcallit returns false plus the result of err.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>Coroutine management</h3>
                        <p>The operations related to coroutines comprise a sub-library of the basic library and are located in the table coroutine. See §2.11 for an overview of coroutines.</p>
                        <ul>
                            <li>
                                <h4>coroutine.create (f)</h4>
                                <p>Create a new coroutine with a body f. fmust be a Lua function. Returns a new coroutine, an object of type "thread".</p>
                            </li>
                            <li>
                                <h4>coroutine.resume (co [, val1, ···])</h4>
                                <p>Start or continue execution of the coroutine co. The first time this function is called the coroutine begins executing its body. The values val1, ··· are passed as arguments to the body of the function. If the coroutine has given up control of the flow, resumerestart it; The values val1, ··· are passed as results of the transfer.</p>
                                <p>If the coroutine executes without error, resumeit returns true plus the values passed to yield(if the coroutine performs the transfer) or the values returned by the body of the function (if the coroutine terminates). If any error exists, resumeit returns false plus an error message.</p>
                            </li>
                            <li>
                                <h4>coroutine.running ()</h4>
                                <p>Returns the running coroutine or nil when invoked from the main process.</p>
                            </li>
                            <li>
                                <h4>coroutine.status (co)</h4>
                                <p>Returns the status of the coroutine coas a string : "running", if the coroutine is running (that is, it invoked status); "suspended", if the coroutine is suspended on a call to yield, or if it has not yet started executing; "normal"if the coroutine is active but not running (that is, if it has resumed another coroutine); and "dead"whether the coroutine has finished its function or stopped with an error.</p>
                            </li>
                            <li>
                                <h4>coroutine.wrap (f)</h4>
                                <p>Create a new coroutine with a body f. fmust be a Lua function. Returns a function that summarizes the coroutine each time it is invoked. Any argument passed to the function behaves as an extra argument to resume. Returns the same values returned by resume, except the first boolean. In case of error, it is propagated.</p>
                            </li>
                            <li>
                                <h4>coroutine.yield (···)</h4>
                                <p>Suspends the execution of the invoking coroutine. The coroutine cannot be executing a C function, metamethod, or iterator. Any arguments of yieldare passed as extra results to resume.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>Modules</h3>
                        <p>The packaging library provides basic utilities for loading and building modules in Lua. Exports two of its functions directly to the global environment: moduleand require. The others are exported in the table package.</p>
                        <ul>
                            <li>
                                <h4>module (nombre [, ···])</h4>
                                <p>Create a module. If a table exists in package.loaded[nombre]this it is the module. In another case, if there is a global table twith the given name, this is the module. Otherwise, finally, it creates a new table tand gives it the global name of nombreand the value of package.loaded[nombre]. This function also initializes t._NAMEwith the given name, t._Mwith the module ( titself), and t._PACKAGEwith the package name (the nombreentire module minus its last component; see below). Finally, moduleit establishes tthe new environment of the current function and the new value of package.loaded[nombre], so that it requirereturns t.</p>
                                <p>If nombreit is a compound name (that is, one with components separated by periods) modulecreate (or reuse, if they already exist) tables for each component. For example, if nombreis a.b.c, then moduleit stores the module table in the global table cfield field .ba</p>
                                <p>This function can receive optional arguments after the module name, where each option is a function that will be applied on the module.</p>
                            </li>
                            <li>
                                <h4>require (nombre)</h4>
                                <p>Load the given module. The function begins by searching the table package.loadedto determine if nombreit is already loaded. If so then requireit returns the value stored in package.loaded[nombre]. Otherwise try to find a loader for the module.</p>
                                <p>To find a charger, you first requirefollow package.preload[nombre]. Changing this array changes the way it requiresearches for a module. The following explanation is based on the default configuration of package.loaders.</p>
                                <p>First requirelook at package.prelodad[modname]. If it has a value, this (which must be a function) is the loader. Otherwise requiresearch for a loader in Lua using the search path saved in package.path. If this also fails, look for a C loader using the path stored in package.cpath. If this also fails, try an all-in-one charger (see package.loaders).</p>
                                <p>Once the loader has been found, requireit invokes it with a single argument, nombre. If the loader returns a value, requireit assigns it to package.loaded[nombre]. If the loader does not return a value and a value is not assigned to package.loaded[nombre], then requireit assigns true to this input. In any case, requireit returns the final value of package.loaded[nombre].</p>
                                <p>If there are errors during loading or execution of the module in progress or if a loader for the module could not be found, then it requiretriggers an error.</p>
                            </li>
                            <li>
                                <h4>package.cpath</h4>
                                <p>The search path used by requireto search for a C loader.</p>
                                <p>Lua initializes this path package.cpaththe same way it initializes the Lua path package.path, using the environment variable LUA_CPATH(in addition to another default path defined in luaconf.h).</p>
                            </li>
                            <li>
                                <h4>package.loaded</h4>
                                <p>A table used by requireto control which modules are already loaded. When a module is requested nombreand package.loaded[nombre]it is not false, requireit simply returns the stored value.</p>
                            </li>
                            <li>
                                <h4>package.loaders</h4>
                                <p>A table used because requireit controls how modules are loaded</p>
                                <p>Each entry in this table is a finder function . When it searches for a module, requireit calls each of those search engines in ascending order, with the module name (the argument passed to require) as the only argument. The function can return another function (the loader module or a string explaining that it did not find that module (or nil if it had nothing to say). Lua initializes this table with four functions.</p>
                                <p>The first search engine simply looks for a loader in the table package.preload.</p>
                                <p>The second search engine searches for a loader as a Lua library, using the search path saved in package.path. A path is a sequence of templates separated by semicolons ( ;). In each template, the browser changes each question mark that appears to nombre_de_fichero, which is the name of the module with each period replaced by a "directory separator" (such as "/" on Unix); then it will try to open the file with the resulting name. So, for example, if the Lua path is the string :</p>
                                <code>"./?.lua;./?.lc;/usr/local/?/init.lua"</code>
                                <p>searching for a Lua source file for the module foowill attempt to open the files ./foo.lua., ./foo.lcand /usr/local/foo/init.lua, in that order</p>
                                <p>The third search engine searches for a loader as a C library, using the path given in the variable package.cpath. For example, if the C path is the string :</p>
                                <code>"./?.so;./?.dll;/usr/local/?/init.so"</code>
                                <p>The search engine, for the module, foowill try to open the files ./foo.so., ./foo.dlland /usr/local/foo/init.so, in that order. Once it finds a C library, the finder uses the dynamic link utility to link the application to the library. Then try to find the C function within the library to be used as a loader. The name of this function is the string "luaopen_" concatenated with a copy of the module name where each period is replaced by an underscore character ( _). Additionally, if the module name has a hyphen, its prefix up to the first included hyphen is removed. For example, if the module name is a.v1-b.cthe function name will be luaopen_b_c.</p>
                                <p>The fourth seeker tries an all-in-one charger . Searches the C path for a library with the root name of the given module. For example, when requested it a.b.cwill search aa C library. IF it finds it, it searches within it for a function to open the submodule; In our example, it would be luaopen_a_b_c. With this utility, a package can store multiple C submodules in a single library, with each submodule maintaining its original opening function.</p>
                            </li>
                            <li>
                                <h4>package.loadlib (nombre_de_biblioteca, nombre_de_func)</h4>
                                <p>Dynamically links the host program with the C library nombre_de_biblio. Within this library it looks for a function nombre_de_funcand returns it as a C function. (Therefore, nombre_de_funcit must follow the protocol; see lua_CFunction).</p>
                                <p>This is a low level function. It completely skips the package and module system. Unlike require, it doesn't perform any searches along the way and doesn't automatically add extensions. nombre_de_bibliomust be a full C library file name, including the full path and extension if necessary. nombre_de_funcmust be the exact name exported by the C library (which may depend on the C compiler and operating system loader used).</p>
                                <p>This function is not supported by ANSI C. Therefore it is only available on some platforms (Windows, Linux, Mac OS X, Solaris, BSD, as well as other Unix systems that support the standard dlfcn).</p>
                            </li>
                            <li>
                                <h4>package.path</h4>
                                <p>The search path used by requireto search for a Lua loader.</p>
                                <p>At first Lua initializes this variable with the value of the environment variable LUA_PATHor with a default path defined in luaconf.h, if the environment variable is not defined. If it appears ";;"in the value of the environment variable, it is replaced by the default path.</p>
                            </li>
                            <li>
                                <h4>package.preload</h4>
                                <p>A table that stores loaders for specific modules (see require).</p>
                            </li>
                            <li>
                                <h4>package.seeall (módulo)</h4>
                                <p>It establishes a metatable for móduloits field __indexreferring to the global environment, such that this module inherits the values from the global environment. It is used as an option for the function module.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>String management</h3>
                        <p>This library provides generic string handling functions , such as finding and extracting substrings and detecting patterns . When a string is indexed in Lua the first character is at position 1 (not 0 like in C). The use of negative indexes is allowed, which are interpreted as indexing backwards from the end of the string . Therefore the last character of the string is in position -1, and so on.</p>
                        <p>The string library provides all its functions in the table string. It also sets a metatable for string where the field __indexpoints to the same metatable. Therefore, you can use string handling functions in an object-oriented style. For example, string.byte(s, i)you can put s:byte(i).</p>
                        <ul>
                            <li>
                                <h4>string.byte (s [, i [, j]])</h4>
                                <p>Returns the internal numeric codes of the characters s[i], s[i+1], ···, s[j]. The default value of iis 1; the default value of jis i.</p>
                                <p>Keep in mind that numerical codes are not necessarily portable from one platform to another.</p>
                            </li>
                            <li>
                                <h4>string.char (···)</h4>
                                <p>Receives zero or more integers. Returns a string with the same length as the number of arguments, in which each character has an internal numeric code equal to its corresponding argument.</p>
                                <p>Keep in mind that numerical codes are not necessarily portable from one platform to another.</p>
                            </li>
                            <li>
                                <h4>string.dump (function)</h4>
                                <p>Returns a string containing the binary representation of the given function, such that a subsequent call to loadstringwith this string returns a copy of the function. funcmust be a Lua function without upvalues.</p>
                            </li>
                            <li>
                                <h4>string.find (s, patrón [, inicio [, básica]])</h4>
                                <p>Find the first occurrence of patrónin the string s . If it finds it, findit returns the indexes of swhere the appearance begins and ends; otherwise it returns nil . An optional third numeric argument iniciospecifies where to start the search; Its default value is 1 and can be negative. A value of true as the optional fourth argument básicadisables the pattern detection utilities, the function then performing a "basic substring search " operation, with no "magic" characters in the patrón. Note that if the argument is supplied básicathe argument must also be supplied inicio.</p>
                                <p>If the pattern has captures then on a successful detection the captured values are returned, after the two indices.</p>
                            </li>
                            <li>
                                <h4>string.format (formato, ···)</h4>
                                <p>Returns a formatted version of its arguments (in variable number) following the description given in its first argument ( formato, which must be a string ). The format stringprintf follows the same rules as the standard C family of functions . *The only differences are that the , l, L, n, p, and options/modifiers hare not supported, and that there is an extra option q. This last option formats a string in a form suitable for being safely read back by the Lua interpreter: the string is enclosed in double quotes, and all double quotes, newlines, zeros, and backslashes in the string are replaced by appropriate escape sequences in writing. For example, the call</p>
                                <code>string.format('%q', 'a string with "quotes" and \n new line')</code>
                                <p>will produce the string :</p>
                                <code>"a string with \"quotes\" and \</code><br>
                                <code> new line"</code>
                                <p>The options c, d, E, e, f, g, G, i, o, u, Xand xexpect a number as an argument, while qand sexpect a string .</p>
                                <p>This function does not accept string values containing zero characters, except as arguments to the option q.</p>
                            </li>
                            <li>
                                <h4>string.gmatch (s, patrón)</h4>
                                <p>Returns an iterator function that, each time it is called, returns the following captures of the patrónin the string s .</p>
                                <p>If the patróndoes not produce catches then the full match is returned on each call.</p>
                                <p>As an example, the following loop</p>
                                <code>s = "hello world from Lua"</code><br>
                                <code>for w in string.gmatch(s, "%a+") do</code><br>
                                <code>print(w)</code><br>
                                <code>end</code>
                                <p>will iterate over all the words in the string s , printing one per line. clave=valorThe following example returns all pairs of the given string in table form :</p>
                                <code>t = {}</code><br>
                                <code>s = "from=world, to=Lua"</code><br>
                                <code>for k, v in string.gmatch(s, "(%w+)=(%w+)") do</code><br>
                                <code>t[k] = v</code><br>
                                <code>end</code>
                                <p>For this function, a '^'at the beginning of a pattern does not function as an anchor, but instead prevents iteration.</p>
                            </li>
                            <li>
                                <h4>string.gsub (s, patrón, reemplazamiento [, n])</h4>
                                <p>Returns a copy of sin which all (or the nfirst, if the optional argument is specified) occurrences of patrónhave been replaced by the reemplazamientospecified one, which can be a string , a table, or a function. gsubIt also returns, as a second value, the total number of matches detected.</p>
                                <p>If reemplazamientoit is a string then its value is used in the substitution. The character functions as an% escape character: any sequence in reemplazamientoof the form %n , with n between 1 and 9, means the value of the nth capture in the substring (see below). The sequence means the entire coincidence. The sequence means a percentage character .%0%%%</p>
                                <p>If reemplazamientoit is a table, then in each capture the element of the table whose key is the first capture is returned; if the pattern does not provide any capture then the entire match is used as a key.</p>
                                <p>If reemplazamientoit is a function then it is called every time there is a capture with all the captured substrings passed as arguments in the same order; if no catches exist then the entire match is passed as a single argument.</p>
                                <p>If the value returned by the table or function call is a string or a number, then it is used as the replacement string ; otherwise if false or nil , then no substitution is performed (that is, the original match is kept in the string ).</p>
                                <p>Here are some examples:</p>
                                <code>x = string.gsub("hello world", "(%w+)", "%1 %1")</code><br>
                                <code>--&gt; x="hello hello world world"</code><br>
                                <br>
                                <code>x = string.gsub("hello world", "%w+", "%0 %0", 1)</code><br>
                                <code>--&gt; x="hello hello world"</code><br>
                                <br>
                                <code>x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")</code><br>
                                <code>--&gt; x="world hello Lua from"</code><br>
                                <br>
                                <code>x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)</code><br>
                                <code>--&gt; x="home = /home/roberto, user = roberto"</code><br>
                                <br>
                                <code>x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)</code><br>
                                <code>return loadstring(s)()</code><br>
                                <code>end)</code><br>
                                <code>--&gt; x="4+5 = 9"</code><br>
                                <br>
                                <code>local t = {name="lua", version="5.1"}</code><br>
                                <code>x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)</code><br>
                                <code>--&gt; x="lua-5.1.tar.gz"</code><br>
                                <br>
                            </li>
                            <li>
                                <h4>string.len (s)</h4>
                                <p>Receives a string and returns its length. The empty string"" has length 0. Zero characters within the string are also counted, so it "a\000bc\000"has length 5.</p>
                            </li>
                            <li>
                                <h4>string.lower (s)</h4>
                                <p>Receives a string and returns a copy of it with all uppercase letters changed to lowercase. The rest of the characters remain unchanged. The definition of capital letter depends on the local system.</p>
                            </li>
                            <li>
                                <h4>string.match (s, patrón [, inicio])</h4>
                                <p>Find the first occurrence of patrónin the string s . If it finds one, then matchit returns the pattern capture ; otherwise it returns nil . If the patróndoes not produce any capture then the full match is returned. A third, optional numeric argument iniciospecifies where to start the search; Its default value is 1 and can be negative.</p>
                            </li>
                            <li>
                                <h4>string.rep (s, n)</h4>
                                <p>Returns a string that is the concatenation of ncopies of the string s .</p>
                            </li>
                            <li>
                                <h4>string.reverse (s)</h4>
                                <p>Returns a string that is the original sinverted.</p>
                            </li>
                            <li>
                                <h4>string.sub (s, i [, j])</h4>
                                <p>Returns the substring of sstarting at iand continuing to j; iand jthey can be negative. If jit is absent then it is assumed to be -1 (equivalent to the length of the string ). In particular, the call string.sub(s,1,j)returns a prefix of swith length j, and string.sub(s, -i)returns a suffix of swith length i.</p>
                            </li>
                            <li>
                                <h4>string.upper (s)</h4>
                                <p>Receives a string and returns a copy of it with all lowercase letters changed to uppercase. The rest of the characters remain unchanged. The definition of lowercase letter depends on the local system.</p>
                            </li>
                            <li>
                                <h4>Patterns</h4>
                                    <ul>
                                            <li>
                                                    <h5>Character classes: </h5>
                                                        <p>are used to represent character sets. The following combinations are allowed to describe a character class:</p>
                                                        <ul>
                                                            <li>
                                                                <p>x : (where x is not one of the magic characters ) represents the character x^$()%.[]*+-? itself.</p>
                                                            </li>
                                                            <li>
                                                                <p>.: (a dot) represents any character.</p>
                                                            </li>
                                                            <li>
                                                                <p>%a: represents any letter.</p>
                                                            </li>
                                                            <li>
                                                                <p>%c: represents any control character.</p>
                                                            </li>
                                                            <li>
                                                                <p>%d: represents any digit.</p>
                                                            </li>
                                                            <li>
                                                                <p>%l: represents any lowercase letter.</p>
                                                            </li>
                                                            <li>
                                                                <p>%p: represents any punctuation character.</p>
                                                            </li>
                                                            <li>
                                                                <p>%s: represents any space character.</p>
                                                            </li>
                                                            <li>
                                                                <p>%u: represents any uppercase letter.</p>
                                                            </li>
                                                            <li>
                                                                <p>%w: represents any alphanumeric character.</p>
                                                            </li>
                                                            <li>
                                                                <p>%x: represents any hexadecimal digit.</p>
                                                            </li>
                                                            <li>
                                                                <p>%z: represents the character with internal value 0 (zero).</p>
                                                            </li>
                                                            <li>
                                                                <p>%x: (where x is any non-alphanumeric character) represents the character x . This is the standard way to "escape" magical characters. Any punctuation character (even non-magical ones) can be preceded by a percentage sign ' %' when they want to represent themselves in the pattern.</p>
                                                            </li>
                                                            <li>
                                                                <p>[conjunto]: represents the class that is the union of all the characters in the set . A range of characters can be specified by separating the beginning and ending character with a hyphen ' -'. All classes of type %x described above can also be used as components of the set . All other characters in the set represent themselves. For example, [%w_](or [_%w]) represents any alphanumeric character or the underscore, [0-7]represents an octal digit, and [0-7%l%-]represents an octal digit, a lowercase letter, or the character ' -'.</p>
                                                                <p>The interaction between ranks and classes is not defined. Therefore, patterns like [%a-z]or [a-%%]are meaningless.</p>
                                                            </li>
                                                            <li>
                                                                <p>[^conjunto]: represents the complement of set , where set is interpreted as above.</p>
                                                            </li>
                                                        </ul>
                                                        <p>For all classes represented by simple letters ( %a, %c, etc.) the corresponding capital letters represent the complementary class. For example, %Srepresents any non-space character.</p>
                                                        <p>The definitions of letter, space, and other character groups depend on the local system. In particular, the class [a-z]may not be equivalent to %l.</p>
                                                    </li>
                                                    <li>
                                                        <h5>Elements of a pattern</h5>
                                                        <p>Each element of a pattern can be</p>
                                                        <ul>
                                                            <li>
                                                                <p>a simple character class, which is equivalent to any simple character in the class;</p>
                                                            </li>
                                                            <li>
                                                                <p>a single character class followed by ' *', which is equivalent to 0 or more repetitions of the characters in the class. These repeat elements will always equal the longest possible character sequence;</p>
                                                            </li>
                                                            <li>
                                                                <p>a single character class followed by ' +', which is equivalent to 1 or more repetitions of the characters in the class. These repeat elements will always equal the longest possible character sequence;</p>
                                                            </li>
                                                            <li>
                                                                <p>a single character class followed by ' -', which is also equivalent to 0 or more repetitions of the characters in the class. Unlike ' *', these repeat elements will always equal the shortest possible character sequence;</p>
                                                            </li>
                                                            <li>
                                                                <p>a single character class followed by ' ?', which is equivalent to 0 or 1 occurrences of a character in the class;</p>
                                                            </li>
                                                            <li>
                                                                <p>%n , for n between 1 and 9; This element is equivalent to a substring equal to capture number n ;</p>
                                                            </li>
                                                            <li>
                                                                <p>%bxy , where x and y are two different characters; This element is equivalent to strings that start with x , end with y , with x and y being balanced . This means that, starting a counter at 0, if the string is read from left to right, adding +1 for each x that appears and -1 for each y , the final y is the first one where the counter reaches 0. For example, the element is equivalent to an expression with paired parentheses.%b()</p>
                                                            </li>
                                                        </ul>
                                                    </li>
                                                    <li>
                                                        <h5>Pattern</h5>
                                                        <p>A pattern is a sequence of pattern elements. A ' ^' at the beginning of a pattern anchors the search for the pattern to the beginning of the string in which the search occurs. A ' $' at the end of a pattern anchors the search for the pattern to the end of the string on which the search occurs. In other positions ' ^' and ' $' do not have a special meaning and represent themselves.</p>
                                                    </li>
                                                    <li>
                                                        <h5>Captures</h5>
                                                        <p>A pattern can contain subpatterns enclosed in parentheses that describe captures . When a match occurs between a pattern and a given string , the substrings that match what is indicated in parentheses in the pattern are stored ( captured ) for future use. Captures are numbered according to their left parentheses. For example, in the pattern "(a*(.)%w(%s*))", the part of the string that matches "a*(.)%w(%s*)"is saved in the first capture (and therefore has number 1); the character that matches "."is captured with the number 2, and the part that matches "%s*"is captured with the number 3.</p>
                                                        <p>As a special case, the empty capture ()returns the current position in the string (a number). For example, if the pattern is applied "()aa()"to string "flaaap" , it will give two captures: 3 and 5.</p>
                                                        <p>A pattern cannot contain zero characters. Use %zinstead.</p>
                                                    </li>
                                                </ul>
                                        </li>
                                </ul>
                        </li>
                    <li>
                        <h3>Table management</h3>
                        <p>This library provides generic functions for table management. All these functions are defined within the table table.</p>
                        <p>Most functions in the table library assume that they represent arrays or lists (that is, they are numerically indexed). For these functions, when we talk about the "length" of a table we mean the result of the length operator ( #).</p>
                        <ul>
                            <li>
                                <h4>table.concat (tabla [, separador [, i [, j]]])</h4>
                                <p>Given a table where all its elements are strings or numbers returns tabla[i]..separador..tabla[i+1] ··· separador..tabla[j]. The default value of separadoris the empty string , the default value of iis 1, and the default value of jis the length of the table. If iit is greater than j, the function returns an empty string .</p>
                            </li>
                            <li>
                                <h4>table.insert (tabla, [posición,] valor)</h4>
                                <p>Inserts the element valorinto the posicióngiven element tabla, moving other elements forward to make room, if necessary. The default value of posiciónis n+1, where n = #tablais the length of the table (see §2.5.5 ), so it table.insert(t,x)inserts xat the end of the table t.</p>
                            </li>
                            <li>
                                <h4>table.maxn (tabla)</h4>
                                <p>Returns the largest positive numeric index of a given table or zero if the table has no positive numeric indexes. (To do its job this function performs a linear sweep of the entire table.)</p>
                            </li>
                            <li>
                                <h4>table.remove (tabla [, posición])</h4>
                                <p>Removes from tablathe given element posición, moving back other elements to close space, if necessary. Returns the value of the removed element. The default value of posiciónis n, where nis the length of the table, so the call table.remove(t)removes the last element from the table t.</p>
                            </li>
                            <li>
                                <h4>table.sort (tabla [, comparador])</h4>
                                <p>Sorts the table elements in a given order by modifying the table itself , from table[1]to table[n], where nis the length of the table. If the argument is given comparadorit must be a function that takes two elements from the table and returns true when the first is less than the second (so it not comparador(a[i+1],a[i])will be true after sorting). If a function is not provided then the standard Lua comparadoroperator is used .<</p>
                                <p>The sorting algorithm is not stable; that is, elements considered equal by the given sort may undergo relative order changes after the sort.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>Mathematical functions</h3>
                        <p>This library is an interface to the C standard math library. It provides all of its functions within the table math.</p>
                        <ul>
                            <li>
                                <h4>math.abs (x)</h4>
                                <p>Returns the absolute value of x.</p>
                            </li>
                            <li>
                                <h4>math.acos (x)</h4>
                                <p>Returns the arc cosine of x(in radians).</p>
                            </li>
                            <li>
                                <h4>math.asin (x)</h4>
                                <p>Returns the arc sine of x(in radians).</p>
                            </li>
                            <li>
                                <h4>math.atan (x)</h4>
                                <p>Returns the arctangent of x(in radians).</p>
                            </li>
                            <li>
                                <h4>math.atan2 (y, x)</h4>
                                <p>Returns the arctangent of y/x(in radians), but uses the signs of both arguments to determine the quadrant of the result. (It also correctly handles the case where xit is zero.)</p>
                            </li>
                            <li>
                                <h4>math.ceil (x)</h4>
                                <p>Returns the smallest integer greater than or equal to x.</p>
                            </li>
                            <li>
                                <h4>math.cos (x)</h4>
                                <p>Returns the cosine of x(assumed to be in radians).</p>
                            </li>
                            <li>
                                <h4>math.cosh (x)</h4>
                                <p>Returns the hyperbolic cosine of x.</p>
                            </li>
                            <li>
                                <h4>math.deg (x)</h4>
                                <p>xReturns the value of (given in radians) in sexagesimal degrees .</p>
                            </li>
                            <li>
                                <h4>math.exp (x)</h4>
                                <p>Returns the value of e x .</p>
                            </li>
                            <li>
                                <h4>math.floor (x)</h4>
                                <p>Returns the largest integer less than or equal to x.</p>
                            </li>
                            <li>
                                <h4>math.fmod (x, y)</h4>
                                <p>Returns the remainder of the division of xby y.</p>
                            </li>
                            <li>
                                <h4>math.frexp (x)</h4>
                                <p>Returns my esuch that x = m 2 e , eis an integer and the absolute value of mis in the interval [0.5, 1) (or zero when xzero).</p>
                            </li>
                            <li>
                                <h4>math.huge</h4>
                                <p>The value HUGE_VAL, a value greater than or equal to any other numerical value.</p>
                            </li>
                            <li>
                                <h4>math.ldexp (m, e)</h4>
                                <p>Returns m 2 e ( emust be an integer).</p>
                            </li>
                            <li>
                                <h4>math.log (x)</h4>
                                <p>Returns the natural logarithm of x.</p>
                            </li>
                            <li>
                                <h4>math.log10 (x)</h4>
                                <p>Returns the decimal logarithm (base 10) of x.</p>
                            </li>
                            <li>
                                <h4>math.max (x, ···)</h4>
                                <p>Returns the largest value among its arguments.</p>
                            </li>
                            <li>
                                <h4>math.min (x, ···)</h4>
                                <p>Returns the smallest value among its arguments.</p>
                            </li>
                            <li>
                                <h4>math.modf (x)</h4>
                                <p>Returns two numbers, the integer and fractional parts of x.</p>
                            </li>
                            <li>
                                <h4>math.pi</h4>
                                <p>The value of pi .</p>
                            </li>
                            <li>
                                <h4>math.pow (x, y)</h4>
                                <p>Returns x y . (You can also use the expression x^yto calculate this value.)</p>
                            </li>
                            <li>
                                <h4>math.rad (x)</h4>
                                <p>Returns the value of the angle in radians x(given in sexagesimal degrees).</p>
                            </li>
                            <li>
                                <h4>math.random ([m [, n]])</h4>
                                <p>This function is an interface to a randsimple, pseudo-random number generator provided by ANSI C. (No guarantees of its statistical properties.)</p>
                                <p>When called without arguments it returns a uniform real pseudorandom number in the range [0,1). When called with an integer m, math.randomreturns a uniform integer pseudorandom number in the range [1, m]. When called with two arguments mand nintegers, math.randomit returns a uniform integer pseudorandom number in the range [m, n].</p>
                            </li>
                            <li>
                                <h4>math.randomseed (x)</h4>
                                <p>Set xas "seed" for the pseudorandom number generator: equal seeds produce equal sequences of numbers.</p>
                            </li>
                            <li>
                                <h4>math.sin (x)</h4>
                                <p>Returns the sine of x(assumed to be in radians).</p>
                            </li>
                            <li>
                                <h4>math.sinh (x)</h4>
                                <p>Returns the hyperbolic sine of x.</p>
                            </li>
                            <li>
                                <h4>math.sqrt (x)</h4>
                                <p>Returns the square root of x. (You can also use the expression x^0.5to calculate this value.)</p>
                            </li>
                            <li>
                                <h4>math.tan (x)</h4>
                                <p>Returns the tangent of x(assumed to be in radians).</p>
                            </li>
                            <li>
                                <h4>math.tanh (x)</h4>
                                <p>Returns the hyperbolic tangent of x.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>Input/Output Utilities</h3>
                        <p>The input/output (I/O) library provides two different styles of file handling. The first of them uses implicit file descriptors; That is, there are two default files, one input and one output, and operations are performed on them. The second style uses explicit file descriptors.</p>
                        <p>When using implicit descriptors all supported operations are in the table io. When using explicit descriptors, the operation io.openreturns a file descriptor and all operations are provided as methods associated with the descriptor.</p>
                        <p>The table ioalso provides three predefined file descriptors with their usual C meanings: io.stdin, io.stdoute io.stderr. The input/output library never closes those files.</p>
                        <p>Unless specified, all input/output functions return nil on failure (plus an error message as a second result and a system-dependent error code as a third result) and values other than nil on success. .</p>
                        <ul>
                            <li>
                                <h4>io.close ([descriptor_de_fichero])</h4>
                                <p>Equivalent to descriptor_de_fichero:close(). Without argument closes the output file by default.</p>
                            </li>
                            <li>
                                <h4>io.flush ()</h4>
                                <p>Equivalent to descriptor_de_fichero:flushapplied to the default output file.</p>
                            </li>
                            <li>
                                <h4>io.input ([descriptor_de_fichero | nombre_de_fichero])</h4>
                                <p>When invoked with a file name it then opens it (in text mode), and sets its file handle as the default input file. When called with a file descriptor it simply sets it as the handle for the input file by default. When invoked without an argument it returns the current default file.</p>
                                <p>In case of errors this function activates errorinstead of returning an error code.</p>
                            </li>
                            <li>
                                <h4>io.lines ([nombre_de_fichero])</h4>
                                <p>Opens the file with the given name in read mode and returns an iterator function that, each time it is called, returns a new line of the file. Therefore, the construction</p>
                                <code>for line in io.lines(file_name) do block end</code>
                                <p>It will iterate over all the lines in the file. When the iterator function detects the end of the file, it returns nil (to end the loop) and automatically closes the file.</p>
                                <p>The call to io.lines()(without file name) is equivalent to io.input():lines(); that is, it iterates over all the lines of the input default file. In that case it does not close the file when the loop ends.</p>
                            </li>
                            <li>
                                <h4>io.open (nombre_de_fichero [, modo])</h4>
                                <p>This function opens a file, in the mode specified in the string mode . Returns a file descriptor or, in case of error, nil as well as an error message.</p>
                                <p>The string indicated modocan be one of the following:</p>
                                <ul>
                                    <li>"r": reading mode (default);</li>
                                    <li>"w": write mode;</li>
                                    <li>"a": addition mode;</li>
                                    <li>"r+": update mode, all pre-existing data is kept;</li>
                                    <li>"w+": update mode, all pre-existing data is deleted;</li>
                                    <li>"a+": addition mode with update, all pre-existing data is kept, and writing is allowed only at the end of the file.</li>
                                </ul>
                                <p>The string indicated by the modomay also contain ' b' at the end, which is necessary on some systems to open the file in binary mode. This string is exactly the one used in the standard C function fopen.</p>
                            </li>
                            <li>
                                <h4>io.output ([descriptor_de_fichero | nombre_de_fichero])</h4>
                                <p>Similar to io.input, but operating on the default output file.</p>
                            </li>
                            <li>
                                <h4>io.popen (prog [, modo])</h4>
                                <p>Starts running the program progin a separate process and returns a file descriptor that can be used to read data that it writes prog(if modoit is "r", the default) or to write data that it reads prog(if modoit is "w").</p>
                                <p>This feature is operating system dependent and not available on all platforms.</p>
                            </li>
                            <li>
                                <h4>io.read (···)</h4>
                                <p>Equivalent to io.input():read.</p>
                            </li>
                            <li>
                                <h4>io.tmpfile ()</h4>
                                <p>Returns a file descriptor for a temporary file. This opens in update mode and is automatically deleted when the program ends.</p>
                            </li>
                            <li>
                                <h4>io.type (objeto)</h4>
                                <p>Checks if objetoit is a valid file descriptor. Returns string "file" if objetoit is an open file descriptor, "closed file"if objetoit is a closed file descriptor, or nil if objetoit is not a file descriptor.</p>
                            </li>
                            <li>
                                <h4>io.write (···)</h4>
                                <p>Equivalent to io.output():write.</p>
                            </li>
                            <li>
                                <h4>descriptor_de_fichero:close ()</h4>
                                <p>Close the file descriptor descriptor_de_fichero. Note that files are automatically closed when their descriptors are removed in a memory release cycle, but that this takes an unpredictable execution time.</p>
                            </li>
                            <li>
                                <h4>descriptor_de_fichero:flush ()</h4>
                                <p>Save any data written in descriptor_de_fichero.</p>
                            </li>
                            <li>
                                <h4>descriptor_de_fichero:lines ()</h4>
                                <p>Returns an iterator function that, each time it is called, returns a new line read from the file. Therefore, the construction</p>
                                <code>for line in file_descriptor:lines() do block end</code>
                                <p>It will iterate over all the lines in the file. (Unlike io.lines, this function does not close the file when the loop ends.)</p>
                            </li>
                            <li>
                                <h4>file:read (···)</h4>
                                <p>Reads the file given by descriptor_de_fichero, according to the format provided, which specifies what to read. For each format, the function returns a string (or a number) with the characters read, or nil if it could not read the data in the specified format. When called raw a default is used that reads the entire next line (see below).</p>
                                <p>The available formats are</p>
                                <ul>
                                    <li>
                                        <p>"*n": read a number; This is the only format that returns a number instead of a string .</p>
                                    </li>
                                    <li>
                                        <p>"*a": reads the rest of the entire file, starting at the current position. At the end of the file it returns an empty string .</p>
                                    </li>
                                    <li>
                                        <p>"*l": reads the next line (skipping the end of the line), returning nil at the end of the file. This is the default format.</p>
                                    </li>
                                    <li>
                                        <p>a number : reads a string with at most this number of characters, returning nil if the end of the file is reached. If the number is zero, it does not read anything and returns an empty string , or nil if the end of the file is reached.</p>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <h4>file:seek ([de_dónde] [, desplazamiento])</h4>
                                <p>Sets (or requests) the current position (of the read/write pointer) in the string descriptor_de_fichero, measured from the beginning of the file, to the position given by desplazamientoplus the base specified by the string dónde , as specified below:</p>
                                <ul>
                                    <li>
                                        <p>"set": sets the base position to 0 (beginning of the file);</p>
                                    </li>
                                    <li>
                                        <p>"cur": places the base position at the current one;</p>
                                    </li>
                                    <li>
                                        <p>"end": places the base position at the end of the file.</p>
                                    </li>
                                </ul>
                                <p>If successful, the function seekreturns the final position (of the read/write pointer) in the file measured in bytes from the beginning of the file. If the call fails, it returns nil , plus a string describing the error.</p>
                                <p>The default value of dóndeis "cur", and for desplazamientois 0. Therefore, the call descriptor_de_fichero:seek()returns the current position, without changing it; the call descriptor_de_fichero:seek("set")sets the position to the beginning of the file (and returns 0); and the call descriptor_de_fichero:seek("end")sets the position at the end of the file and returns its size.</p>
                            </li>
                            <li>
                                <h4>file:setvbuf (modo [, tamaño])</h4>
                                <p>Sets a buffer mode for an output file. The argument modocan be one of these three:</p>
                                <ul>
                                    <li>
                                        <p>"no": no buffer ; the result of any output operation occurs immediately.</p>
                                    </li>
                                    <li>
                                        <p>"full": with full buffer ; the output operation is performed only when the buffer is full or when the function is explicitly invoked flushin the file descriptor.</p>
                                    </li>
                                    <li>
                                        <p>"line": with line buffer ; The output is delayed until a new line is produced in the output or there is an entry in some special file (such as a terminal).</p>
                                    </li>
                                </ul>
                                <p>For the last two cases, tamañospecify the size of the buffer , in bytes. The default value is a suitable size.</p>
                            </li>
                            <li>
                                <h4>file:write (···)</h4>
                                <p>Writes the value of its arguments to the file given by su descriptor_de_fichero. The arguments can be strings or numbers. To write other values use tostringor string.formatbefore write.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>Operating system utilities</h3>
                        <p>This library is implemented through the table os.</p>
                        <ul>
                            <li>
                                <h4>os.clock ()</h4>
                                <p>Returns an approximation of the total CPU seconds used by the program.</p>
                            </li>
                            <li>
                                <h4>os.date ([formato [, tiempo]])</h4>
                                <p>Returns a string or a table containing the date and time, formatted according to the string given informato .</p>
                                <p>If the argument tiempois present then that particular time is the one that is formatted (see the function os.timefor a description of this value). Otherwise, dateformat the current time.</p>
                                <p>If formatoit starts with ' !' then the time is formatted according to Coordinated Universal Time. After this optional character, if formatois *tthen datereturns a table with the following fields: year(four digits), month(1--12), day(1--31), hour(0--23), min(0--59), sec(0--61), wday(day of week, Sunday is 1), yday(day within year), e isdst(boolean, true if daylight saving time).</p>
                                <p>If formatonot *tthen dateit returns the time as a string , formatted according to the same rules as the strftimeC function.</p>
                                <p>When called without arguments dateit returns a reasonable representation of the date and time that depends on the machine and the local system (that is, it os.date()is equivalent to os.date("%c")).</p>
                            </li>
                            <li>
                                <h4>os.difftime (t2, t1)</h4>
                                <p>Returns the number of seconds from instant t1to t2. On POSIX, Windows and some other systems this value is exactly t2-t1 .</p>
                            </li>
                            <li>
                                <h4>os.execute ([comando])</h4>
                                <p>This function is equivalent to the systemC function. It passes the command comandoto be executed in the operating system's command interpreter. Returns a status code, which is system dependent. If the argument comandois absent it returns a non-zero value if a shell is available and zero if it is not available.</p>
                            </li>
                            <li>
                                <h4>os.exit ([código])</h4>
                                <p>Invokes the exitC function, with an códigooptional integer, to terminate the host program. The default value of códigois the value corresponding to success.</p>
                            </li>
                            <li>
                                <h4>os.getenv (variable)</h4>
                                <p>Returns the value assigned to the environment variable variable, or nil if the variable is not defined.</p>
                            </li>
                            <li>
                                <h4>os.remove (nombre_de_fichero)</h4>
                                <p>Delete the given file or directory. Directories must be empty to be deleted. If the function fails, it returns nil , plus a string describing the error.</p>
                            </li>
                            <li>
                                <h4>os.rename (nombre_viejo, nombre_nuevo)</h4>
                                <p>Rename a file or directory from nombre_viejoto nombre_nuevo. If the function fails, it returns nil , plus a string describing the error.</p>
                            </li>
                            <li>
                                <h4>os.setlocale (local [, categoría])</h4>
                                <p>Sets values on the program's local system. localis a string that specifies a local value; categoríais an optional string that describes which category to change: "all", "collate", "ctype", "monetary", "numeric", or "time"; The default category is "all". This function returns the name of the new location or nil if the request could not be accepted.</p>
                                <p>If localit is the empty string , the current locale is set to the native locale (which is implementation dependent). If localstring "C", the current locale is set to the standard C locale.</p>
                                <p>When called with nil as the first argument, this function returns only the name of the current location in the given category.</p>
                            </li>
                            <li>
                                <h4>os.time ([tabla])</h4>
                                <p>Returns the current time when called without arguments, or a time representing the date and time specified in the given table. This must have the fields year, monthand day, and can have the fields hour, min, secand isdst(for a description of those fields, see the function os.date).</p>
                                <p>The returned value is a number, the meaning of which depends on the system. On POSIX, Windows, and some other systems this number counts the number of seconds since some given initial date (the "epoch"). In other systems the meaning is not specified, and the number returned by timecan be used only as an argument to the dateand functions difftime.</p>
                            </li>
                            <li>
                                <h4>os.tmpname ()</h4>
                                <p>Returns a string with a file name that can be used as a temporary file. The file must be explicitly opened before use and also explicitly deleted when no longer needed.</p>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>The debugging library</h3>
                        <p>This library provides Lua programs with debugging interface functionality. It should be used with care. The functions provided here should be used exclusively for debugging and similar tasks, such as code analysis. Please resist the temptation to use the library as a programming tool: it can be very slow. Furthermore, some of its functions violate some of the assumptions about Lua code (for example, that local variables of a function cannot be accessed from outside the function or that userdata cannot be changed from Lua code) and therefore they can compromise otherwise secure code.</p>
                        <p>All functions of this library are provided in the table debug.</p>
                        <ul>
                            <li>
                                <h4>debug.debug ()</h4>
                                <p>It enters interactive mode with the user, executing each string that the user enters. Using simple commands and other debugging utilities the user can inspect global and local variables, change their values, evaluate expressions, etc. A line containing only the word contterminates this function, so the calling program continues execution.</p>
                                <p>Note that the for commands degub.debugare not lexically nested within any function, and do not have direct access to local variables.</p>
                            </li>
                            <li>
                                <h4>debug.getfenv (o)</h4>
                                <p>Returns the environment of the object o.</p>
                            </li>
                            <li>
                                <h4>debug.gethook ([proceso])</h4>
                                <p>Returns information about the current hook of the process, in the form of three values: the function of the current hook , the mask of the current hook , and the counter of the current hook (as set by the function debug.sethook).</p>
                            </li>
                            <li>
                                <h4>debug.getinfo ([proceso,] func [, qué])</h4>
                                <p>Returns a table with information about the function func. You can give the function directly, or you can give a number in place of func, which means the function at the execution level of the stack call: level 0 is that of the current function ( getinfosame ); level 1 is the function that called getinfo; and so on. If funcit is a number greater than the total number of active functions then getinfoit returns nil .</p>
                                <p>The returned table contains all the fields returned by lua_getinfo, with the string qué describing the fields to be filled. By default, if not provided qué, all available information is obtained. If present, the ' f' option adds a field named funcwith the same function. If present, the ' L' option adds a field named activelineswith the table of valid lines.</p>
                                <p>For example, the expression debug.getinfo(1,"n").nombrereturns a table with a name for the current function, if it could find a reasonable name, and debug.getinfo(print)returns a table with all available information about the function print.</p>
                            </li>
                            <li>
                                <h4>debug.getlocal ([proceso,] nivel, local)</h4>
                                <p>This function returns the name and value of a local variable with index localof the function to nivelthe given stack. (The first argument or local variable has index 1, and so on, until the last active local variable.) The function returns nil if a local variable with the given index does not exist, and raises an error when called nivelout of range. (You can call debug.getinfoto check if the level is valid.)</p>
                                <p>Variable names starting with ' &#40;' (open parentheses) represent internal variables (loop control, temporary, and C function locals).</p>
                            </li>
                            <li>
                                <h4>debug.getmetatable (objeto)</h4>
                                <p>Returns the metatable of the objetogiven or nil if it does not have a metatable.</p>
                            </li>
                            <li>
                                <h4>debug.getregistry ()</h4>
                                <p>Returns the registration table.</p>
                            </li>
                            <li>
                                <h4>debug.getupvalue (func, up)</h4>
                                <p>This function returns the name and value of the upvalue with index upof the function func. The function returns nil if there is no upvalue with the given index.</p>
                            </li>
                            <li>
                                <h4>debug.setfenv (objeto, tabla)</h4>
                                <p>Sets the tablaenvironment of a objetodie.</p>
                            </li>
                            <li>
                                <h4>debug.sethook ([proceso,] func_hook, máscara [, contador])</h4>
                                <p>Set the function func_hookas hook . The given stringmáscara and number describe how the hookcontador is invoked . The mask can have the following characters, with the indicated meaning:</p>
                                <ul>
                                    <li>
                                        <p>"c": The hook is invoked every time Lua calls a function;</p>
                                    </li>
                                    <li>
                                        <p>"r": The hook is invoked every time Lua returns from a function;</p>
                                    </li>
                                    <li>
                                        <p>"l": The hook is invoked every time Lua enters a new line of code.</p>
                                    </li>
                                </ul>
                                <p>With a contadornon-zero hook the hook is invoked every that number of instructions.</p>
                                <p>When invoked without arguments debug.sethookit disables the hook .</p>
                                <p>When the hook is invoked, its first argument is a string describing the event that triggered its invocation: "call", "return"(or "tail return"), "line"and "count". For line events, the hook also returns the line number as the second value. Within a hook you can call getinfowith level 2 to obtain more information about the running function (level 0 is the function getinfoand level 1 is the hook function ), unless the event is "tail return". In that case Lua only simulates the return, and a call to getinfowill return invalid data.</p>
                            </li>
                            <li>
                                <h4>debug.setlocal ([proceso,] nivel, local, valor)</h4>
                                <p>This function assigns the valorlocal variable with index localof the function to the nivelgiven one on the stack, returning the name of the local variable. The function returns nil if a local variable with the given index does not exist, and raises an error when called with an nivelout-of-range. (Can be invoked getinfoto check if the level is valid.)</p>
                            </li>
                            <li>
                                <h4>debug.setmetatable (objeto, tabla)</h4>
                                <p>Sets tabla(which can be nil) as the metatable of the objetodie.</p>
                            </li>
                            <li>
                                <h4>debug.setupvalue (func, up, valor)</h4>
                                <p>This function assigns the valorto the upvalue with index upof the function func, returning the name of the upvalue . The function returns nil if the upvalue with the given index does not exist .</p>
                            </li>
                            <li>
                                <h4>debug.traceback ([proceso,] [mensaje] [, nivel])</h4>
                                <p>Returns a string with the "reverse trace" of the call on the stack. An mensajeoptional is added to the beginning of the "reverse plot". An optional number nivelindicates at what level the "reverse trace" begins (defaults to 1, the function you are calling traceback).</p>
                            </li>
                        </ul>
                    </li>
                </ol>
            </section>
            <section class="main-section" id="standalone-language">
                <header>Lua as a standalone language</header>
                <p>Although Lua has been designed as an extension language, to be embedded in C programs, it is also frequently used as a stand-alone language. A stand-alone interpreter simply called lua. This includes all the standard libraries, including the debugging one. It is used like this:</p>
                <code>lua [options] [script_file [arguments]]</code>
                <p>The options are:</p>
                <ul>
                    <li>
                        <p>-e statement : execute the string statement ;</p>
                    </li>
                    <li>
                        <p>-l module : load module with functionrequire;</p>
                    </li>
                    <li>
                        <p>-i: enters interactive mode after executing the script_file ;</p>
                    </li>
                    <li>
                        <p>-v: print version information;</p>
                    </li>
                    <li>
                        <p>--: Stop processing options on the rest of the line;</p>
                    </li>
                    <li>
                        <p>-: takes stdinas a file to execute and does not process any more options.</p>
                    </li>
                </ul>
                <p>After managing the given options, luaexecute the given script_file , passing the given arguments as strings . When invoked without arguments luait behaves as lua -v -iwhen standard input ( stdin) is a terminal, and as lua -otherwise.</p>
                <p>Before executing any argument the interpreter checks if an environment variable exists LUA_INIT. If its format is @ file_name then luaexecute this file. Otherwise it executes the stringlua itself .</p>
                <p>All options are processed in order, except -i. For example, an invocation like</p>
                <code>$ lua -e'b=1' -e 'print(b)' script.lua</code>
                <p>It will first set the value of bto 1, then print the value of b(which is ' 1'), and finally execute the file script.luawith no arguments. (Here $is the operating system's command interpreter prompt . Each specific system may be different.)</p>
                <p>Before starting to execute script_file lua it collects all the command line arguments into a global table called arg. The name of the script_file is saved at index 0, the first argument after the program name is saved at index 1, and so on. Any arguments before the program name (that is, the interpreter name plus options) go to negative indices. For example, in the invocation</p>
                <code>$lua -la b.lua t1 t2</code>
                <p>the interpreter first executes the file b.lua, then creates the table</p>
                <code>arg = { [-2] = "lua", [-1] = "-la",</code><br>
                <code>[0] = "b.lua",</code><br>
                <code>[1] = "t1", [2] = "t2" }</code>
                <p>and finally execute the file b.lua. This is invoked with arg[1], arg[2], ··· as arguments; These arguments are also accessed with the expression vararg '... '.</p>
                <p>In interactive mode, if an incomplete statement is written, the interpreter waits for it to be completed, indicating it with a different prompt .</p>
                <p>If the global variable _PROMPTcontains a string then its value is used as a prompt . Similarly, if the global variable _PROMPT2contains a string its value is used as a secondary prompt (the one used during incomplete statements). Therefore, both prompts can be changed directly on the command line or in any Lua program by assigning a value to _PROMPT. See the following example:</p>
                <code>$ lua -e"_PROMPT='myprompt> '" -i</code>
                <p>(the outer pair of quotes is for the operating system's shell; the inner one is for Lua.) Note the use of -ito enter interactive mode; Otherwise the program would silently terminate just after assignment to_PROMPT .</p>
                <p>To allow the use of Lua as a script interpreter on Unix systems, the standalone Lua interpreter skips the first line of a chunk if it begins with #. Therefore, Lua programs can be converted to executables using chmod +xand form #!, as in</p>
                <code>#!/usr/local/bin/lua</code>
                <p>(Of course, the location of the Lua interpreter may be different on each machine. If luayou are on the path of searching for executables,PATH then</p>
                <code>#!/usr/bin/env lua</code>
                <p>It is a more portable solution.)</p>
            </section>
        </div>

    </main>
</body>
</html>